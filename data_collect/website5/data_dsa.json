{
    "link": {
        "0": "https:\/\/www.hackerrank.com\/challenges\/arrays-ds?isFullScreen=true",
        "1": "https:\/\/www.hackerrank.com\/challenges\/2d-array?isFullScreen=true",
        "2": "https:\/\/www.hackerrank.com\/challenges\/dynamic-array?isFullScreen=true",
        "3": "https:\/\/www.hackerrank.com\/challenges\/array-left-rotation?isFullScreen=true",
        "4": "https:\/\/www.hackerrank.com\/challenges\/sparse-arrays?isFullScreen=true",
        "5": "https:\/\/www.hackerrank.com\/challenges\/crush?isFullScreen=true",
        "6": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list?isFullScreen=true",
        "7": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-tail-of-a-linked-list?isFullScreen=true",
        "8": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-head-of-a-linked-list?isFullScreen=true",
        "9": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-a-specific-position-in-a-linked-list?isFullScreen=true",
        "10": "https:\/\/www.hackerrank.com\/challenges\/delete-a-node-from-a-linked-list?isFullScreen=true",
        "11": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list-in-reverse?isFullScreen=true",
        "12": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-linked-list?isFullScreen=true",
        "13": "https:\/\/www.hackerrank.com\/challenges\/compare-two-linked-lists?isFullScreen=true",
        "14": "https:\/\/www.hackerrank.com\/challenges\/merge-two-sorted-linked-lists?isFullScreen=true",
        "15": "https:\/\/www.hackerrank.com\/challenges\/get-the-value-of-the-node-at-a-specific-position-from-the-tail?isFullScreen=true",
        "16": "https:\/\/www.hackerrank.com\/challenges\/delete-duplicate-value-nodes-from-a-sorted-linked-list?isFullScreen=true",
        "17": "https:\/\/www.hackerrank.com\/challenges\/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true",
        "18": "https:\/\/www.hackerrank.com\/challenges\/find-the-merge-point-of-two-joined-linked-lists?isFullScreen=true",
        "19": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-into-a-sorted-doubly-linked-list?isFullScreen=true",
        "20": "https:\/\/www.hackerrank.com\/challenges\/arrays-ds?isFullScreen=true",
        "21": "https:\/\/www.hackerrank.com\/challenges\/2d-array?isFullScreen=true",
        "22": "https:\/\/www.hackerrank.com\/challenges\/dynamic-array?isFullScreen=true",
        "23": "https:\/\/www.hackerrank.com\/challenges\/array-left-rotation?isFullScreen=true",
        "24": "https:\/\/www.hackerrank.com\/challenges\/sparse-arrays?isFullScreen=true",
        "25": "https:\/\/www.hackerrank.com\/challenges\/crush?isFullScreen=true",
        "26": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list?isFullScreen=true",
        "27": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-tail-of-a-linked-list?isFullScreen=true",
        "28": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-head-of-a-linked-list?isFullScreen=true",
        "29": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-a-specific-position-in-a-linked-list?isFullScreen=true",
        "30": "https:\/\/www.hackerrank.com\/challenges\/delete-a-node-from-a-linked-list?isFullScreen=true",
        "31": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list-in-reverse?isFullScreen=true",
        "32": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-linked-list?isFullScreen=true",
        "33": "https:\/\/www.hackerrank.com\/challenges\/compare-two-linked-lists?isFullScreen=true",
        "34": "https:\/\/www.hackerrank.com\/challenges\/merge-two-sorted-linked-lists?isFullScreen=true",
        "35": "https:\/\/www.hackerrank.com\/challenges\/get-the-value-of-the-node-at-a-specific-position-from-the-tail?isFullScreen=true",
        "36": "https:\/\/www.hackerrank.com\/challenges\/delete-duplicate-value-nodes-from-a-sorted-linked-list?isFullScreen=true",
        "37": "https:\/\/www.hackerrank.com\/challenges\/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true",
        "38": "https:\/\/www.hackerrank.com\/challenges\/find-the-merge-point-of-two-joined-linked-lists?isFullScreen=true",
        "39": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-into-a-sorted-doubly-linked-list?isFullScreen=true",
        "40": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-doubly-linked-list?isFullScreen=true",
        "41": "https:\/\/www.hackerrank.com\/challenges\/tree-preorder-traversal?isFullScreen=true",
        "42": "https:\/\/www.hackerrank.com\/challenges\/tree-postorder-traversal?isFullScreen=true",
        "43": "https:\/\/www.hackerrank.com\/challenges\/tree-inorder-traversal?isFullScreen=true",
        "44": "https:\/\/www.hackerrank.com\/challenges\/tree-height-of-a-binary-tree?isFullScreen=true",
        "45": "https:\/\/www.hackerrank.com\/challenges\/tree-top-view?isFullScreen=true",
        "46": "https:\/\/www.hackerrank.com\/challenges\/tree-level-order-traversal?isFullScreen=true",
        "47": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-insertion?isFullScreen=true",
        "48": "https:\/\/www.hackerrank.com\/challenges\/tree-huffman-decoding?isFullScreen=true",
        "49": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-lowest-common-ancestor?isFullScreen=true",
        "50": "https:\/\/www.hackerrank.com\/challenges\/arrays-ds?isFullScreen=true",
        "51": "https:\/\/www.hackerrank.com\/challenges\/2d-array?isFullScreen=true",
        "52": "https:\/\/www.hackerrank.com\/challenges\/dynamic-array?isFullScreen=true",
        "53": "https:\/\/www.hackerrank.com\/challenges\/array-left-rotation?isFullScreen=true",
        "54": "https:\/\/www.hackerrank.com\/challenges\/sparse-arrays?isFullScreen=true",
        "55": "https:\/\/www.hackerrank.com\/challenges\/crush?isFullScreen=true",
        "56": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list?isFullScreen=true",
        "57": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-tail-of-a-linked-list?isFullScreen=true",
        "58": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-head-of-a-linked-list?isFullScreen=true",
        "59": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-a-specific-position-in-a-linked-list?isFullScreen=true",
        "60": "https:\/\/www.hackerrank.com\/challenges\/delete-a-node-from-a-linked-list?isFullScreen=true",
        "61": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list-in-reverse?isFullScreen=true",
        "62": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-linked-list?isFullScreen=true",
        "63": "https:\/\/www.hackerrank.com\/challenges\/compare-two-linked-lists?isFullScreen=true",
        "64": "https:\/\/www.hackerrank.com\/challenges\/merge-two-sorted-linked-lists?isFullScreen=true",
        "65": "https:\/\/www.hackerrank.com\/challenges\/get-the-value-of-the-node-at-a-specific-position-from-the-tail?isFullScreen=true",
        "66": "https:\/\/www.hackerrank.com\/challenges\/delete-duplicate-value-nodes-from-a-sorted-linked-list?isFullScreen=true",
        "67": "https:\/\/www.hackerrank.com\/challenges\/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true",
        "68": "https:\/\/www.hackerrank.com\/challenges\/find-the-merge-point-of-two-joined-linked-lists?isFullScreen=true",
        "69": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-into-a-sorted-doubly-linked-list?isFullScreen=true",
        "70": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-doubly-linked-list?isFullScreen=true",
        "71": "https:\/\/www.hackerrank.com\/challenges\/tree-preorder-traversal?isFullScreen=true",
        "72": "https:\/\/www.hackerrank.com\/challenges\/tree-postorder-traversal?isFullScreen=true",
        "73": "https:\/\/www.hackerrank.com\/challenges\/tree-inorder-traversal?isFullScreen=true",
        "74": "https:\/\/www.hackerrank.com\/challenges\/tree-height-of-a-binary-tree?isFullScreen=true",
        "75": "https:\/\/www.hackerrank.com\/challenges\/tree-top-view?isFullScreen=true",
        "76": "https:\/\/www.hackerrank.com\/challenges\/tree-level-order-traversal?isFullScreen=true",
        "77": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-insertion?isFullScreen=true",
        "78": "https:\/\/www.hackerrank.com\/challenges\/tree-huffman-decoding?isFullScreen=true",
        "79": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-lowest-common-ancestor?isFullScreen=true",
        "80": "https:\/\/www.hackerrank.com\/challenges\/swap-nodes-algo?isFullScreen=true",
        "81": "https:\/\/www.hackerrank.com\/challenges\/kittys-calculations-on-a-tree?isFullScreen=true",
        "82": "https:\/\/www.hackerrank.com\/challenges\/is-binary-search-tree?isFullScreen=true",
        "83": "https:\/\/www.hackerrank.com\/challenges\/square-ten-tree?isFullScreen=true",
        "84": "https:\/\/www.hackerrank.com\/challenges\/balanced-forest?isFullScreen=true",
        "85": "https:\/\/www.hackerrank.com\/challenges\/jenny-subtrees?isFullScreen=true",
        "86": "https:\/\/www.hackerrank.com\/challenges\/tree-coordinates?isFullScreen=true",
        "87": "https:\/\/www.hackerrank.com\/challenges\/array-pairs?isFullScreen=true",
        "88": "https:\/\/www.hackerrank.com\/challenges\/self-balancing-tree?isFullScreen=true",
        "89": "https:\/\/www.hackerrank.com\/challenges\/array-and-simple-queries?isFullScreen=true",
        "90": "https:\/\/www.hackerrank.com\/challenges\/arrays-ds?isFullScreen=true",
        "91": "https:\/\/www.hackerrank.com\/challenges\/2d-array?isFullScreen=true",
        "92": "https:\/\/www.hackerrank.com\/challenges\/dynamic-array?isFullScreen=true",
        "93": "https:\/\/www.hackerrank.com\/challenges\/array-left-rotation?isFullScreen=true",
        "94": "https:\/\/www.hackerrank.com\/challenges\/sparse-arrays?isFullScreen=true",
        "95": "https:\/\/www.hackerrank.com\/challenges\/crush?isFullScreen=true",
        "96": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list?isFullScreen=true",
        "97": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-tail-of-a-linked-list?isFullScreen=true",
        "98": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-head-of-a-linked-list?isFullScreen=true",
        "99": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-a-specific-position-in-a-linked-list?isFullScreen=true",
        "100": "https:\/\/www.hackerrank.com\/challenges\/delete-a-node-from-a-linked-list?isFullScreen=true",
        "101": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list-in-reverse?isFullScreen=true",
        "102": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-linked-list?isFullScreen=true",
        "103": "https:\/\/www.hackerrank.com\/challenges\/compare-two-linked-lists?isFullScreen=true",
        "104": "https:\/\/www.hackerrank.com\/challenges\/merge-two-sorted-linked-lists?isFullScreen=true",
        "105": "https:\/\/www.hackerrank.com\/challenges\/get-the-value-of-the-node-at-a-specific-position-from-the-tail?isFullScreen=true",
        "106": "https:\/\/www.hackerrank.com\/challenges\/delete-duplicate-value-nodes-from-a-sorted-linked-list?isFullScreen=true",
        "107": "https:\/\/www.hackerrank.com\/challenges\/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true",
        "108": "https:\/\/www.hackerrank.com\/challenges\/find-the-merge-point-of-two-joined-linked-lists?isFullScreen=true",
        "109": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-into-a-sorted-doubly-linked-list?isFullScreen=true",
        "110": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-doubly-linked-list?isFullScreen=true",
        "111": "https:\/\/www.hackerrank.com\/challenges\/tree-preorder-traversal?isFullScreen=true",
        "112": "https:\/\/www.hackerrank.com\/challenges\/tree-postorder-traversal?isFullScreen=true",
        "113": "https:\/\/www.hackerrank.com\/challenges\/tree-inorder-traversal?isFullScreen=true",
        "114": "https:\/\/www.hackerrank.com\/challenges\/tree-height-of-a-binary-tree?isFullScreen=true",
        "115": "https:\/\/www.hackerrank.com\/challenges\/tree-top-view?isFullScreen=true",
        "116": "https:\/\/www.hackerrank.com\/challenges\/tree-level-order-traversal?isFullScreen=true",
        "117": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-insertion?isFullScreen=true",
        "118": "https:\/\/www.hackerrank.com\/challenges\/tree-huffman-decoding?isFullScreen=true",
        "119": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-lowest-common-ancestor?isFullScreen=true",
        "120": "https:\/\/www.hackerrank.com\/challenges\/swap-nodes-algo?isFullScreen=true",
        "121": "https:\/\/www.hackerrank.com\/challenges\/kittys-calculations-on-a-tree?isFullScreen=true",
        "122": "https:\/\/www.hackerrank.com\/challenges\/is-binary-search-tree?isFullScreen=true",
        "123": "https:\/\/www.hackerrank.com\/challenges\/square-ten-tree?isFullScreen=true",
        "124": "https:\/\/www.hackerrank.com\/challenges\/balanced-forest?isFullScreen=true",
        "125": "https:\/\/www.hackerrank.com\/challenges\/jenny-subtrees?isFullScreen=true",
        "126": "https:\/\/www.hackerrank.com\/challenges\/tree-coordinates?isFullScreen=true",
        "127": "https:\/\/www.hackerrank.com\/challenges\/array-pairs?isFullScreen=true",
        "128": "https:\/\/www.hackerrank.com\/challenges\/self-balancing-tree?isFullScreen=true",
        "129": "https:\/\/www.hackerrank.com\/challenges\/array-and-simple-queries?isFullScreen=true",
        "130": "https:\/\/www.hackerrank.com\/challenges\/arrays-ds?isFullScreen=true",
        "131": "https:\/\/www.hackerrank.com\/challenges\/2d-array?isFullScreen=true",
        "132": "https:\/\/www.hackerrank.com\/challenges\/dynamic-array?isFullScreen=true",
        "133": "https:\/\/www.hackerrank.com\/challenges\/array-left-rotation?isFullScreen=true",
        "134": "https:\/\/www.hackerrank.com\/challenges\/sparse-arrays?isFullScreen=true",
        "135": "https:\/\/www.hackerrank.com\/challenges\/crush?isFullScreen=true",
        "136": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list?isFullScreen=true",
        "137": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-tail-of-a-linked-list?isFullScreen=true",
        "138": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-head-of-a-linked-list?isFullScreen=true",
        "139": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-a-specific-position-in-a-linked-list?isFullScreen=true",
        "140": "https:\/\/www.hackerrank.com\/challenges\/delete-a-node-from-a-linked-list?isFullScreen=true",
        "141": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list-in-reverse?isFullScreen=true",
        "142": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-linked-list?isFullScreen=true",
        "143": "https:\/\/www.hackerrank.com\/challenges\/compare-two-linked-lists?isFullScreen=true",
        "144": "https:\/\/www.hackerrank.com\/challenges\/merge-two-sorted-linked-lists?isFullScreen=true",
        "145": "https:\/\/www.hackerrank.com\/challenges\/get-the-value-of-the-node-at-a-specific-position-from-the-tail?isFullScreen=true",
        "146": "https:\/\/www.hackerrank.com\/challenges\/delete-duplicate-value-nodes-from-a-sorted-linked-list?isFullScreen=true",
        "147": "https:\/\/www.hackerrank.com\/challenges\/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true",
        "148": "https:\/\/www.hackerrank.com\/challenges\/find-the-merge-point-of-two-joined-linked-lists?isFullScreen=true",
        "149": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-into-a-sorted-doubly-linked-list?isFullScreen=true",
        "150": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-doubly-linked-list?isFullScreen=true",
        "151": "https:\/\/www.hackerrank.com\/challenges\/tree-preorder-traversal?isFullScreen=true",
        "152": "https:\/\/www.hackerrank.com\/challenges\/tree-postorder-traversal?isFullScreen=true",
        "153": "https:\/\/www.hackerrank.com\/challenges\/tree-inorder-traversal?isFullScreen=true",
        "154": "https:\/\/www.hackerrank.com\/challenges\/tree-height-of-a-binary-tree?isFullScreen=true",
        "155": "https:\/\/www.hackerrank.com\/challenges\/tree-top-view?isFullScreen=true",
        "156": "https:\/\/www.hackerrank.com\/challenges\/tree-level-order-traversal?isFullScreen=true",
        "157": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-insertion?isFullScreen=true",
        "158": "https:\/\/www.hackerrank.com\/challenges\/tree-huffman-decoding?isFullScreen=true",
        "159": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-lowest-common-ancestor?isFullScreen=true",
        "160": "https:\/\/www.hackerrank.com\/challenges\/swap-nodes-algo?isFullScreen=true",
        "161": "https:\/\/www.hackerrank.com\/challenges\/kittys-calculations-on-a-tree?isFullScreen=true",
        "162": "https:\/\/www.hackerrank.com\/challenges\/is-binary-search-tree?isFullScreen=true",
        "163": "https:\/\/www.hackerrank.com\/challenges\/square-ten-tree?isFullScreen=true",
        "164": "https:\/\/www.hackerrank.com\/challenges\/balanced-forest?isFullScreen=true",
        "165": "https:\/\/www.hackerrank.com\/challenges\/jenny-subtrees?isFullScreen=true",
        "166": "https:\/\/www.hackerrank.com\/challenges\/tree-coordinates?isFullScreen=true",
        "167": "https:\/\/www.hackerrank.com\/challenges\/array-pairs?isFullScreen=true",
        "168": "https:\/\/www.hackerrank.com\/challenges\/self-balancing-tree?isFullScreen=true",
        "169": "https:\/\/www.hackerrank.com\/challenges\/array-and-simple-queries?isFullScreen=true",
        "170": "https:\/\/www.hackerrank.com\/challenges\/median?isFullScreen=true",
        "171": "https:\/\/www.hackerrank.com\/challenges\/merging-communities?isFullScreen=true",
        "172": "https:\/\/www.hackerrank.com\/challenges\/qheap1?isFullScreen=true",
        "173": "https:\/\/www.hackerrank.com\/challenges\/maximum-element?isFullScreen=true",
        "174": "https:\/\/www.hackerrank.com\/challenges\/queue-using-two-stacks?isFullScreen=true",
        "175": "https:\/\/www.hackerrank.com\/challenges\/components-in-graph?isFullScreen=true",
        "176": "https:\/\/www.hackerrank.com\/challenges\/balanced-brackets?isFullScreen=true",
        "177": "https:\/\/www.hackerrank.com\/challenges\/castle-on-the-grid?isFullScreen=true",
        "178": "https:\/\/www.hackerrank.com\/challenges\/jesse-and-cookies?isFullScreen=true",
        "179": "https:\/\/www.hackerrank.com\/challenges\/kundu-and-tree?isFullScreen=true",
        "180": "https:\/\/www.hackerrank.com\/challenges\/arrays-ds?isFullScreen=true",
        "181": "https:\/\/www.hackerrank.com\/challenges\/2d-array?isFullScreen=true",
        "182": "https:\/\/www.hackerrank.com\/challenges\/dynamic-array?isFullScreen=true",
        "183": "https:\/\/www.hackerrank.com\/challenges\/array-left-rotation?isFullScreen=true",
        "184": "https:\/\/www.hackerrank.com\/challenges\/sparse-arrays?isFullScreen=true",
        "185": "https:\/\/www.hackerrank.com\/challenges\/crush?isFullScreen=true",
        "186": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list?isFullScreen=true",
        "187": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-tail-of-a-linked-list?isFullScreen=true",
        "188": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-the-head-of-a-linked-list?isFullScreen=true",
        "189": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-at-a-specific-position-in-a-linked-list?isFullScreen=true",
        "190": "https:\/\/www.hackerrank.com\/challenges\/delete-a-node-from-a-linked-list?isFullScreen=true",
        "191": "https:\/\/www.hackerrank.com\/challenges\/print-the-elements-of-a-linked-list-in-reverse?isFullScreen=true",
        "192": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-linked-list?isFullScreen=true",
        "193": "https:\/\/www.hackerrank.com\/challenges\/compare-two-linked-lists?isFullScreen=true",
        "194": "https:\/\/www.hackerrank.com\/challenges\/merge-two-sorted-linked-lists?isFullScreen=true",
        "195": "https:\/\/www.hackerrank.com\/challenges\/get-the-value-of-the-node-at-a-specific-position-from-the-tail?isFullScreen=true",
        "196": "https:\/\/www.hackerrank.com\/challenges\/delete-duplicate-value-nodes-from-a-sorted-linked-list?isFullScreen=true",
        "197": "https:\/\/www.hackerrank.com\/challenges\/detect-whether-a-linked-list-contains-a-cycle?isFullScreen=true",
        "198": "https:\/\/www.hackerrank.com\/challenges\/find-the-merge-point-of-two-joined-linked-lists?isFullScreen=true",
        "199": "https:\/\/www.hackerrank.com\/challenges\/insert-a-node-into-a-sorted-doubly-linked-list?isFullScreen=true",
        "200": "https:\/\/www.hackerrank.com\/challenges\/reverse-a-doubly-linked-list?isFullScreen=true",
        "201": "https:\/\/www.hackerrank.com\/challenges\/tree-preorder-traversal?isFullScreen=true",
        "202": "https:\/\/www.hackerrank.com\/challenges\/tree-postorder-traversal?isFullScreen=true",
        "203": "https:\/\/www.hackerrank.com\/challenges\/tree-inorder-traversal?isFullScreen=true",
        "204": "https:\/\/www.hackerrank.com\/challenges\/tree-height-of-a-binary-tree?isFullScreen=true",
        "205": "https:\/\/www.hackerrank.com\/challenges\/tree-top-view?isFullScreen=true",
        "206": "https:\/\/www.hackerrank.com\/challenges\/tree-level-order-traversal?isFullScreen=true",
        "207": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-insertion?isFullScreen=true",
        "208": "https:\/\/www.hackerrank.com\/challenges\/tree-huffman-decoding?isFullScreen=true",
        "209": "https:\/\/www.hackerrank.com\/challenges\/binary-search-tree-lowest-common-ancestor?isFullScreen=true",
        "210": "https:\/\/www.hackerrank.com\/challenges\/swap-nodes-algo?isFullScreen=true",
        "211": "https:\/\/www.hackerrank.com\/challenges\/kittys-calculations-on-a-tree?isFullScreen=true",
        "212": "https:\/\/www.hackerrank.com\/challenges\/is-binary-search-tree?isFullScreen=true",
        "213": "https:\/\/www.hackerrank.com\/challenges\/square-ten-tree?isFullScreen=true",
        "214": "https:\/\/www.hackerrank.com\/challenges\/balanced-forest?isFullScreen=true",
        "215": "https:\/\/www.hackerrank.com\/challenges\/jenny-subtrees?isFullScreen=true",
        "216": "https:\/\/www.hackerrank.com\/challenges\/tree-coordinates?isFullScreen=true",
        "217": "https:\/\/www.hackerrank.com\/challenges\/array-pairs?isFullScreen=true",
        "218": "https:\/\/www.hackerrank.com\/challenges\/self-balancing-tree?isFullScreen=true",
        "219": "https:\/\/www.hackerrank.com\/challenges\/array-and-simple-queries?isFullScreen=true",
        "220": "https:\/\/www.hackerrank.com\/challenges\/median?isFullScreen=true",
        "221": "https:\/\/www.hackerrank.com\/challenges\/merging-communities?isFullScreen=true",
        "222": "https:\/\/www.hackerrank.com\/challenges\/qheap1?isFullScreen=true",
        "223": "https:\/\/www.hackerrank.com\/challenges\/maximum-element?isFullScreen=true"
    },
    "diff": {
        "0": "Easy",
        "1": "Easy",
        "2": "Easy",
        "3": "Easy",
        "4": "Medium",
        "5": "Hard",
        "6": "Easy",
        "7": "Easy",
        "8": "Easy",
        "9": "Easy",
        "10": "Easy",
        "11": "Easy",
        "12": "Easy",
        "13": "Easy",
        "14": "Easy",
        "15": "Easy",
        "16": "Easy",
        "17": "Medium",
        "18": "Easy",
        "19": "Easy",
        "20": "Easy",
        "21": "Easy",
        "22": "Easy",
        "23": "Easy",
        "24": "Medium",
        "25": "Hard",
        "26": "Easy",
        "27": "Easy",
        "28": "Easy",
        "29": "Easy",
        "30": "Easy",
        "31": "Easy",
        "32": "Easy",
        "33": "Easy",
        "34": "Easy",
        "35": "Easy",
        "36": "Easy",
        "37": "Medium",
        "38": "Easy",
        "39": "Easy",
        "40": "Easy",
        "41": "Easy",
        "42": "Easy",
        "43": "Easy",
        "44": "Easy",
        "45": "Easy",
        "46": "Easy",
        "47": "Easy",
        "48": "Medium",
        "49": "Easy",
        "50": "Easy",
        "51": "Easy",
        "52": "Easy",
        "53": "Easy",
        "54": "Medium",
        "55": "Hard",
        "56": "Easy",
        "57": "Easy",
        "58": "Easy",
        "59": "Easy",
        "60": "Easy",
        "61": "Easy",
        "62": "Easy",
        "63": "Easy",
        "64": "Easy",
        "65": "Easy",
        "66": "Easy",
        "67": "Medium",
        "68": "Easy",
        "69": "Easy",
        "70": "Easy",
        "71": "Easy",
        "72": "Easy",
        "73": "Easy",
        "74": "Easy",
        "75": "Easy",
        "76": "Easy",
        "77": "Easy",
        "78": "Medium",
        "79": "Easy",
        "80": "Medium",
        "81": "Advanced",
        "82": "Medium",
        "83": "Hard",
        "84": "Hard",
        "85": "Hard",
        "86": "Expert",
        "87": "Advanced",
        "88": "Medium",
        "89": "Hard",
        "90": "Easy",
        "91": "Easy",
        "92": "Easy",
        "93": "Easy",
        "94": "Medium",
        "95": "Hard",
        "96": "Easy",
        "97": "Easy",
        "98": "Easy",
        "99": "Easy",
        "100": "Easy",
        "101": "Easy",
        "102": "Easy",
        "103": "Easy",
        "104": "Easy",
        "105": "Easy",
        "106": "Easy",
        "107": "Medium",
        "108": "Easy",
        "109": "Easy",
        "110": "Easy",
        "111": "Easy",
        "112": "Easy",
        "113": "Easy",
        "114": "Easy",
        "115": "Easy",
        "116": "Easy",
        "117": "Easy",
        "118": "Medium",
        "119": "Easy",
        "120": "Medium",
        "121": "Advanced",
        "122": "Medium",
        "123": "Hard",
        "124": "Hard",
        "125": "Hard",
        "126": "Expert",
        "127": "Advanced",
        "128": "Medium",
        "129": "Hard",
        "130": "Easy",
        "131": "Easy",
        "132": "Easy",
        "133": "Easy",
        "134": "Medium",
        "135": "Hard",
        "136": "Easy",
        "137": "Easy",
        "138": "Easy",
        "139": "Easy",
        "140": "Easy",
        "141": "Easy",
        "142": "Easy",
        "143": "Easy",
        "144": "Easy",
        "145": "Easy",
        "146": "Easy",
        "147": "Medium",
        "148": "Easy",
        "149": "Easy",
        "150": "Easy",
        "151": "Easy",
        "152": "Easy",
        "153": "Easy",
        "154": "Easy",
        "155": "Easy",
        "156": "Easy",
        "157": "Easy",
        "158": "Medium",
        "159": "Easy",
        "160": "Medium",
        "161": "Advanced",
        "162": "Medium",
        "163": "Hard",
        "164": "Hard",
        "165": "Hard",
        "166": "Expert",
        "167": "Advanced",
        "168": "Medium",
        "169": "Hard",
        "170": "Hard",
        "171": "Hard",
        "172": "Easy",
        "173": "Easy",
        "174": "Medium",
        "175": "Medium",
        "176": "Medium",
        "177": "Medium",
        "178": "Easy",
        "179": "Hard",
        "180": "Easy",
        "181": "Easy",
        "182": "Easy",
        "183": "Easy",
        "184": "Medium",
        "185": "Hard",
        "186": "Easy",
        "187": "Easy",
        "188": "Easy",
        "189": "Easy",
        "190": "Easy",
        "191": "Easy",
        "192": "Easy",
        "193": "Easy",
        "194": "Easy",
        "195": "Easy",
        "196": "Easy",
        "197": "Medium",
        "198": "Easy",
        "199": "Easy",
        "200": "Easy",
        "201": "Easy",
        "202": "Easy",
        "203": "Easy",
        "204": "Easy",
        "205": "Easy",
        "206": "Easy",
        "207": "Easy",
        "208": "Medium",
        "209": "Easy",
        "210": "Medium",
        "211": "Advanced",
        "212": "Medium",
        "213": "Hard",
        "214": "Hard",
        "215": "Hard",
        "216": "Expert",
        "217": "Advanced",
        "218": "Medium",
        "219": "Hard",
        "220": "Hard",
        "221": "Hard",
        "222": "Easy",
        "223": "Easy"
    },
    "score": {
        "0": "Max Score: 10",
        "1": "Max Score: 15",
        "2": "Max Score: 15",
        "3": "Max Score: 20",
        "4": "Max Score: 25",
        "5": "Max Score: 60",
        "6": "Max Score: 5",
        "7": "Max Score: 5",
        "8": "Max Score: 5",
        "9": "Max Score: 5",
        "10": "Max Score: 5",
        "11": "Max Score: 5",
        "12": "Max Score: 5",
        "13": "Max Score: 5",
        "14": "Max Score: 5",
        "15": "Max Score: 5",
        "16": "Max Score: 5",
        "17": "Max Score: 5",
        "18": "Max Score: 5",
        "19": "Max Score: 5",
        "20": "Max Score: 10",
        "21": "Max Score: 15",
        "22": "Max Score: 15",
        "23": "Max Score: 20",
        "24": "Max Score: 25",
        "25": "Max Score: 60",
        "26": "Max Score: 5",
        "27": "Max Score: 5",
        "28": "Max Score: 5",
        "29": "Max Score: 5",
        "30": "Max Score: 5",
        "31": "Max Score: 5",
        "32": "Max Score: 5",
        "33": "Max Score: 5",
        "34": "Max Score: 5",
        "35": "Max Score: 5",
        "36": "Max Score: 5",
        "37": "Max Score: 5",
        "38": "Max Score: 5",
        "39": "Max Score: 5",
        "40": "Max Score: 5",
        "41": "Max Score: 10",
        "42": "Max Score: 10",
        "43": "Max Score: 10",
        "44": "Max Score: 10",
        "45": "Max Score: 20",
        "46": "Max Score: 20",
        "47": "Max Score: 20",
        "48": "Max Score: 20",
        "49": "Max Score: 30",
        "50": "Max Score: 10",
        "51": "Max Score: 15",
        "52": "Max Score: 15",
        "53": "Max Score: 20",
        "54": "Max Score: 25",
        "55": "Max Score: 60",
        "56": "Max Score: 5",
        "57": "Max Score: 5",
        "58": "Max Score: 5",
        "59": "Max Score: 5",
        "60": "Max Score: 5",
        "61": "Max Score: 5",
        "62": "Max Score: 5",
        "63": "Max Score: 5",
        "64": "Max Score: 5",
        "65": "Max Score: 5",
        "66": "Max Score: 5",
        "67": "Max Score: 5",
        "68": "Max Score: 5",
        "69": "Max Score: 5",
        "70": "Max Score: 5",
        "71": "Max Score: 10",
        "72": "Max Score: 10",
        "73": "Max Score: 10",
        "74": "Max Score: 10",
        "75": "Max Score: 20",
        "76": "Max Score: 20",
        "77": "Max Score: 20",
        "78": "Max Score: 20",
        "79": "Max Score: 30",
        "80": "Max Score: 40",
        "81": "Max Score: 80",
        "82": "Max Score: 30",
        "83": "Max Score: 60",
        "84": "Max Score: 60",
        "85": "Max Score: 70",
        "86": "Max Score: 100",
        "87": "Max Score: 100",
        "88": "Max Score: 50",
        "89": "Max Score: 80",
        "90": "Max Score: 10",
        "91": "Max Score: 15",
        "92": "Max Score: 15",
        "93": "Max Score: 20",
        "94": "Max Score: 25",
        "95": "Max Score: 60",
        "96": "Max Score: 5",
        "97": "Max Score: 5",
        "98": "Max Score: 5",
        "99": "Max Score: 5",
        "100": "Max Score: 5",
        "101": "Max Score: 5",
        "102": "Max Score: 5",
        "103": "Max Score: 5",
        "104": "Max Score: 5",
        "105": "Max Score: 5",
        "106": "Max Score: 5",
        "107": "Max Score: 5",
        "108": "Max Score: 5",
        "109": "Max Score: 5",
        "110": "Max Score: 5",
        "111": "Max Score: 10",
        "112": "Max Score: 10",
        "113": "Max Score: 10",
        "114": "Max Score: 10",
        "115": "Max Score: 20",
        "116": "Max Score: 20",
        "117": "Max Score: 20",
        "118": "Max Score: 20",
        "119": "Max Score: 30",
        "120": "Max Score: 40",
        "121": "Max Score: 80",
        "122": "Max Score: 30",
        "123": "Max Score: 60",
        "124": "Max Score: 60",
        "125": "Max Score: 70",
        "126": "Max Score: 100",
        "127": "Max Score: 100",
        "128": "Max Score: 50",
        "129": "Max Score: 80",
        "130": "Max Score: 10",
        "131": "Max Score: 15",
        "132": "Max Score: 15",
        "133": "Max Score: 20",
        "134": "Max Score: 25",
        "135": "Max Score: 60",
        "136": "Max Score: 5",
        "137": "Max Score: 5",
        "138": "Max Score: 5",
        "139": "Max Score: 5",
        "140": "Max Score: 5",
        "141": "Max Score: 5",
        "142": "Max Score: 5",
        "143": "Max Score: 5",
        "144": "Max Score: 5",
        "145": "Max Score: 5",
        "146": "Max Score: 5",
        "147": "Max Score: 5",
        "148": "Max Score: 5",
        "149": "Max Score: 5",
        "150": "Max Score: 5",
        "151": "Max Score: 10",
        "152": "Max Score: 10",
        "153": "Max Score: 10",
        "154": "Max Score: 10",
        "155": "Max Score: 20",
        "156": "Max Score: 20",
        "157": "Max Score: 20",
        "158": "Max Score: 20",
        "159": "Max Score: 30",
        "160": "Max Score: 40",
        "161": "Max Score: 80",
        "162": "Max Score: 30",
        "163": "Max Score: 60",
        "164": "Max Score: 60",
        "165": "Max Score: 70",
        "166": "Max Score: 100",
        "167": "Max Score: 100",
        "168": "Max Score: 50",
        "169": "Max Score: 80",
        "170": "Max Score: 70",
        "171": "Max Score: 50",
        "172": "Max Score: 25",
        "173": "Max Score: 20",
        "174": "Max Score: 30",
        "175": "Max Score: 50",
        "176": "Max Score: 25",
        "177": "Max Score: 30",
        "178": "Max Score: 25",
        "179": "Max Score: 80",
        "180": "Max Score: 10",
        "181": "Max Score: 15",
        "182": "Max Score: 15",
        "183": "Max Score: 20",
        "184": "Max Score: 25",
        "185": "Max Score: 60",
        "186": "Max Score: 5",
        "187": "Max Score: 5",
        "188": "Max Score: 5",
        "189": "Max Score: 5",
        "190": "Max Score: 5",
        "191": "Max Score: 5",
        "192": "Max Score: 5",
        "193": "Max Score: 5",
        "194": "Max Score: 5",
        "195": "Max Score: 5",
        "196": "Max Score: 5",
        "197": "Max Score: 5",
        "198": "Max Score: 5",
        "199": "Max Score: 5",
        "200": "Max Score: 5",
        "201": "Max Score: 10",
        "202": "Max Score: 10",
        "203": "Max Score: 10",
        "204": "Max Score: 10",
        "205": "Max Score: 20",
        "206": "Max Score: 20",
        "207": "Max Score: 20",
        "208": "Max Score: 20",
        "209": "Max Score: 30",
        "210": "Max Score: 40",
        "211": "Max Score: 80",
        "212": "Max Score: 30",
        "213": "Max Score: 60",
        "214": "Max Score: 60",
        "215": "Max Score: 70",
        "216": "Max Score: 100",
        "217": "Max Score: 100",
        "218": "Max Score: 50",
        "219": "Max Score: 80",
        "220": "Max Score: 70",
        "221": "Max Score: 50",
        "222": "Max Score: 25",
        "223": "Max Score: 20"
    },
    "success rate": {
        "0": "Success Rate: 93.01%",
        "1": "Success Rate: 93.18%",
        "2": "Success Rate: 87.07%",
        "3": "Success Rate: 91.56%",
        "4": "Success Rate: 97.29%",
        "5": "Success Rate: 62.13%",
        "6": "Success Rate: 97.13%",
        "7": "Success Rate: 95.31%",
        "8": "Success Rate: 98.30%",
        "9": "Success Rate: 96.94%",
        "10": "Success Rate: 95.20%",
        "11": "Success Rate: 97.94%",
        "12": "Success Rate: 97.82%",
        "13": "Success Rate: 97.97%",
        "14": "Success Rate: 94.20%",
        "15": "Success Rate: 98.21%",
        "16": "Success Rate: 97.45%",
        "17": "Success Rate: 92.72%",
        "18": "Success Rate: 92.78%",
        "19": "Success Rate: 92.97%",
        "20": "Success Rate: 93.01%",
        "21": "Success Rate: 93.18%",
        "22": "Success Rate: 87.07%",
        "23": "Success Rate: 91.56%",
        "24": "Success Rate: 97.29%",
        "25": "Success Rate: 62.13%",
        "26": "Success Rate: 97.13%",
        "27": "Success Rate: 95.31%",
        "28": "Success Rate: 98.30%",
        "29": "Success Rate: 96.94%",
        "30": "Success Rate: 95.20%",
        "31": "Success Rate: 97.94%",
        "32": "Success Rate: 97.82%",
        "33": "Success Rate: 97.97%",
        "34": "Success Rate: 94.20%",
        "35": "Success Rate: 98.21%",
        "36": "Success Rate: 97.45%",
        "37": "Success Rate: 92.72%",
        "38": "Success Rate: 92.78%",
        "39": "Success Rate: 92.97%",
        "40": "Success Rate: 97.08%",
        "41": "Success Rate: 98.35%",
        "42": "Success Rate: 99.39%",
        "43": "Success Rate: 99.43%",
        "44": "Success Rate: 96.49%",
        "45": "Success Rate: 61.61%",
        "46": "Success Rate: 96.55%",
        "47": "Success Rate: 95.71%",
        "48": "Success Rate: 97.14%",
        "49": "Success Rate: 93.30%",
        "50": "Success Rate: 93.01%",
        "51": "Success Rate: 93.18%",
        "52": "Success Rate: 87.07%",
        "53": "Success Rate: 91.56%",
        "54": "Success Rate: 97.29%",
        "55": "Success Rate: 62.13%",
        "56": "Success Rate: 97.13%",
        "57": "Success Rate: 95.31%",
        "58": "Success Rate: 98.30%",
        "59": "Success Rate: 96.94%",
        "60": "Success Rate: 95.20%",
        "61": "Success Rate: 97.94%",
        "62": "Success Rate: 97.82%",
        "63": "Success Rate: 97.97%",
        "64": "Success Rate: 94.20%",
        "65": "Success Rate: 98.21%",
        "66": "Success Rate: 97.45%",
        "67": "Success Rate: 92.72%",
        "68": "Success Rate: 92.78%",
        "69": "Success Rate: 92.97%",
        "70": "Success Rate: 97.08%",
        "71": "Success Rate: 98.35%",
        "72": "Success Rate: 99.39%",
        "73": "Success Rate: 99.43%",
        "74": "Success Rate: 96.49%",
        "75": "Success Rate: 61.61%",
        "76": "Success Rate: 96.55%",
        "77": "Success Rate: 95.71%",
        "78": "Success Rate: 97.14%",
        "79": "Success Rate: 93.30%",
        "80": "Success Rate: 88.81%",
        "81": "Success Rate: 67.90%",
        "82": "Success Rate: 74.97%",
        "83": "Success Rate: 84.41%",
        "84": "Success Rate: 78.95%",
        "85": "Success Rate: 86.35%",
        "86": "Success Rate: 70.60%",
        "87": "Success Rate: 26.29%",
        "88": "Success Rate: 83.27%",
        "89": "Success Rate: 57.54%",
        "90": "Success Rate: 93.01%",
        "91": "Success Rate: 93.18%",
        "92": "Success Rate: 87.07%",
        "93": "Success Rate: 91.56%",
        "94": "Success Rate: 97.29%",
        "95": "Success Rate: 62.13%",
        "96": "Success Rate: 97.13%",
        "97": "Success Rate: 95.31%",
        "98": "Success Rate: 98.30%",
        "99": "Success Rate: 96.94%",
        "100": "Success Rate: 95.20%",
        "101": "Success Rate: 97.94%",
        "102": "Success Rate: 97.82%",
        "103": "Success Rate: 97.97%",
        "104": "Success Rate: 94.20%",
        "105": "Success Rate: 98.21%",
        "106": "Success Rate: 97.45%",
        "107": "Success Rate: 92.72%",
        "108": "Success Rate: 92.78%",
        "109": "Success Rate: 92.97%",
        "110": "Success Rate: 97.08%",
        "111": "Success Rate: 98.35%",
        "112": "Success Rate: 99.39%",
        "113": "Success Rate: 99.43%",
        "114": "Success Rate: 96.49%",
        "115": "Success Rate: 61.61%",
        "116": "Success Rate: 96.55%",
        "117": "Success Rate: 95.71%",
        "118": "Success Rate: 97.14%",
        "119": "Success Rate: 93.30%",
        "120": "Success Rate: 88.81%",
        "121": "Success Rate: 67.90%",
        "122": "Success Rate: 74.97%",
        "123": "Success Rate: 84.41%",
        "124": "Success Rate: 78.95%",
        "125": "Success Rate: 86.35%",
        "126": "Success Rate: 70.60%",
        "127": "Success Rate: 26.29%",
        "128": "Success Rate: 83.27%",
        "129": "Success Rate: 57.54%",
        "130": "Success Rate: 93.01%",
        "131": "Success Rate: 93.18%",
        "132": "Success Rate: 87.07%",
        "133": "Success Rate: 91.56%",
        "134": "Success Rate: 97.29%",
        "135": "Success Rate: 62.13%",
        "136": "Success Rate: 97.13%",
        "137": "Success Rate: 95.31%",
        "138": "Success Rate: 98.30%",
        "139": "Success Rate: 96.94%",
        "140": "Success Rate: 95.20%",
        "141": "Success Rate: 97.94%",
        "142": "Success Rate: 97.82%",
        "143": "Success Rate: 97.97%",
        "144": "Success Rate: 94.20%",
        "145": "Success Rate: 98.21%",
        "146": "Success Rate: 97.45%",
        "147": "Success Rate: 92.72%",
        "148": "Success Rate: 92.78%",
        "149": "Success Rate: 92.97%",
        "150": "Success Rate: 97.08%",
        "151": "Success Rate: 98.35%",
        "152": "Success Rate: 99.39%",
        "153": "Success Rate: 99.43%",
        "154": "Success Rate: 96.49%",
        "155": "Success Rate: 61.61%",
        "156": "Success Rate: 96.55%",
        "157": "Success Rate: 95.71%",
        "158": "Success Rate: 97.14%",
        "159": "Success Rate: 93.30%",
        "160": "Success Rate: 88.81%",
        "161": "Success Rate: 67.90%",
        "162": "Success Rate: 74.97%",
        "163": "Success Rate: 84.41%",
        "164": "Success Rate: 78.95%",
        "165": "Success Rate: 86.35%",
        "166": "Success Rate: 70.60%",
        "167": "Success Rate: 26.29%",
        "168": "Success Rate: 83.27%",
        "169": "Success Rate: 57.54%",
        "170": "Success Rate: 62.68%",
        "171": "Success Rate: 81.18%",
        "172": "Success Rate: 70.38%",
        "173": "Success Rate: 73.15%",
        "174": "Success Rate: 89.80%",
        "175": "Success Rate: 88.18%",
        "176": "Success Rate: 87.44%",
        "177": "Success Rate: 73.27%",
        "178": "Success Rate: 70.35%",
        "179": "Success Rate: 89.33%",
        "180": "Success Rate: 93.01%",
        "181": "Success Rate: 93.18%",
        "182": "Success Rate: 87.07%",
        "183": "Success Rate: 91.56%",
        "184": "Success Rate: 97.29%",
        "185": "Success Rate: 62.13%",
        "186": "Success Rate: 97.13%",
        "187": "Success Rate: 95.31%",
        "188": "Success Rate: 98.30%",
        "189": "Success Rate: 96.94%",
        "190": "Success Rate: 95.20%",
        "191": "Success Rate: 97.94%",
        "192": "Success Rate: 97.82%",
        "193": "Success Rate: 97.97%",
        "194": "Success Rate: 94.20%",
        "195": "Success Rate: 98.21%",
        "196": "Success Rate: 97.45%",
        "197": "Success Rate: 92.72%",
        "198": "Success Rate: 92.78%",
        "199": "Success Rate: 92.97%",
        "200": "Success Rate: 97.08%",
        "201": "Success Rate: 98.35%",
        "202": "Success Rate: 99.39%",
        "203": "Success Rate: 99.43%",
        "204": "Success Rate: 96.49%",
        "205": "Success Rate: 61.61%",
        "206": "Success Rate: 96.55%",
        "207": "Success Rate: 95.71%",
        "208": "Success Rate: 97.14%",
        "209": "Success Rate: 93.30%",
        "210": "Success Rate: 88.81%",
        "211": "Success Rate: 67.90%",
        "212": "Success Rate: 74.97%",
        "213": "Success Rate: 84.41%",
        "214": "Success Rate: 78.95%",
        "215": "Success Rate: 86.35%",
        "216": "Success Rate: 70.60%",
        "217": "Success Rate: 26.29%",
        "218": "Success Rate: 83.27%",
        "219": "Success Rate: 57.54%",
        "220": "Success Rate: 62.68%",
        "221": "Success Rate: 81.18%",
        "222": "Success Rate: 70.38%",
        "223": "Success Rate: 73.15%"
    },
    "text": {
        "0": "An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index, (where ), that can be referenced as or .\nReverse an array of integers.\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\nExample\nReturn .\nFunction Description\nComplete the function reverseArray in the editor below.\nreverseArray has the following parameter(s):\nint A[n]: the array to reverse\nReturns\nint[n]: the reversed array\nInput Format\nThe first line contains an integer, , the number of integers in .\nThe second line contains space-separated integers that make up .\nConstraints",
        "1": "Given a 2D Array, :\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\nAn hourglass in is a subset of values with indices falling in this pattern in 's graphical representation:\na b c\n  d\ne f g\nThere are hourglasses in . An hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. The array will always be .\nExample\n-9 -9 -9  1 1 1 \n 0 -9  0  4 3 2\n-9 -9 -9  1 2 3\n 0  0  8  6 6 0\n 0  0  0 -2 0 0\n 0  0  1  2 4 0\nThe hourglass sums are:\n-63, -34, -9, 12, \n-10,   0, 28, 23, \n-27, -11, -2, 10, \n  9,  17, 25, 18\nThe highest hourglass sum is from the hourglass beginning at row , column :\n0 4 3\n  1\n8 6 6\nNote: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.\nFunction Description\nComplete the function hourglassSum in the editor below.\nhourglassSum has the following parameter(s):\nint arr[6][6]: an array of integers\nReturns\nint: the maximum hourglass sum\nInput Format\nEach of the lines of inputs contains space-separated integers .\nConstraints\nOutput Format\nPrint the largest (maximum) hourglass sum found in .\nSample Input\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 2 4 4 0\n0 0 0 2 0 0\n0 0 1 2 4 0\nSample Output\n19\nExplanation\ncontains the following hourglasses:\nThe hourglass with the maximum sum () is:\n2 4 4\n  2\n1 2 4",
        "2": "Declare a 2-dimensional array, , of empty arrays. All arrays are zero indexed.\nDeclare an integer, , and initialize it to .\nThere are types of queries, given as an array of strings for you to parse:\nQuery: 1 x y\nLet .\nAppend the integer to .\nQuery: 2 x y\nLet .\nAssign the value to .\nStore the new value of to an answers array.\nNote: is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. is the modulo operator.\nFinally, size(arr[idx]) is the number of elements in arr[idx]\nFunction Description\nComplete the dynamicArray function below.\ndynamicArray has the following parameters:\n- int n: the number of empty arrays to initialize in\n- string queries[q]: query strings that contain 3 space-separated integers\nReturns\nint[]: the results of each type 2 query in the order they are presented\nInput Format\nThe first line contains two space-separated integers, , the size of to create, and , the number of queries, respectively.\nEach of the subsequent lines contains a query string, .\nConstraints\nIt is guaranteed that query type will never query an empty array or index.\nSample Input\n2 5\n1 0 5\n1 1 7\n1 0 3\n2 1 0\n2 1 1\nSample Output\n7\n3\nExplanation\nInitial Values:\n\n\n= [ ]\n= [ ]\nQuery 0: Append to .\n\n= [5]\n= [ ]\nQuery 1: Append to .\n= [5]\n= [7]\nQuery 2: Append to .\n\n= [5, 3]\n= [7]\nQuery 3: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n7\nQuery 4: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n3",
        "3": "A left rotation operation on an array of size shifts each of the array's elements unit to the left. Given an integer, , rotate the array that many steps left and return the result.\nExample\n\nAfter rotations, .\nFunction Description\nComplete the rotateLeft function in the editor below.\nrotateLeft has the following parameters:\nint d: the amount to rotate by\nint arr[n]: the array to rotate\nReturns\nint[n]: the rotated array\nInput Format\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains space-separated integers that describe .\nConstraints\nSample Input\n5 4\n1 2 3 4 5\nSample Output\n5 1 2 3 4\nExplanation\nTo perform left rotations, the array undergoes the following sequence of changes:",
        "4": "There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.\nExample\n\nThere are instances of '', of '' and of ''. For each query, add an element to the return array, .\nFunction Description\nComplete the function matchingStrings in the editor below. The function must return an array of integers representing the frequency of occurrence of each query string in stringList.\nmatchingStrings has the following parameters:\nstring stringList[n] - an array of strings to search\nstring queries[q] - an array of query strings\nReturns\nint[q]: an array of results for each query\nInput Format\nThe first line contains and integer , the size of .\nEach of the next lines contains a string .\nThe next line contains , the size of .\nEach of the next lines contains a string .\nConstraints\n\n\n.",
        "5": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\nExample\n\nQueries are interpreted as follows:\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\nAdd the values of between the indices and inclusive:\nindex->  1 2 3  4  5 6 7 8 9 10\n [0,0,0, 0, 0,0,0,0,0, 0]\n [3,3,3, 3, 3,0,0,0,0, 0]\n [3,3,3,10,10,7,7,7,0, 0]\n [3,3,3,10,10,8,8,8,1, 0]\nThe largest value is after all operations are performed.\nFunction Description\nComplete the function arrayManipulation in the editor below.\narrayManipulation has the following parameters:\nint n - the number of elements in the array\nint queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.\nReturns\nint - the maximum value in the resultant array\nInput Format\nThe first line contains two space-separated integers and , the size of the array and the number of operations.\nEach of the next lines contains three space-separated integers , and , the left index, right index and summand.\nConstraints\nSample Input\n5 3\n1 2 100\n2 5 100\n3 4 100\nSample Output\n200\nExplanation\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\nThe maximum value is .",
        "6": "This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.\nThis is an to practice traversing a linked list. Given a pointer to the head node of a linked list, print each node's element, one per line. If the head pointer is null (indicating the list is empty), there is nothing to print.\nFunction Description\nComplete the printLinkedList function in the editor below.\nprintLinkedList has the following parameter(s):\nSinglyLinkedListNode head: a reference to the head of the list\nPrint\nFor each node, print its value on a new line (console.log in Javascript).\nInput Format\nThe first line of input contains , the number of elements in the linked list.\nThe next lines contain one element each, the values for each node.\nNote: Do not read any input from stdin\/console. Complete the printLinkedList function in the editor below.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n16\n13\nSample Output\n16\n13\nExplanation\nThere are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each on a new line.",
        "7": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nYou are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.\nFunction Description\nComplete the insertNodeAtTail function in the editor below.\ninsertNodeAtTail has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nint data: the data value for the node to insert\nReturns\nSinglyLinkedListNode pointer: reference to the head of the modified linked list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each, the value that needs to be inserted at tail.\nConstraints\nSample Input\nSTDIN Function ----- -------- 5 size of linked list n = 5 141 linked list data values 141..474 302 164 530 474\nSample Output\n141\n302\n164\n530\n474\nExplanation\nFirst the linked list is NULL. After inserting 141, the list is 141 -> NULL.\nAfter inserting 302, the list is 141 -> 302 -> NULL.\nAfter inserting 164, the list is 141 -> 302 -> 164 -> NULL.\nAfter inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.",
        "8": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a linked list, insert a new node before the head. The value in the new node should point to and the value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\nFunction Description\nComplete the function insertNodeAtHead in the editor below.\ninsertNodeAtHead has the following parameter(s):\nSinglyLinkedListNode llist: a reference to the head of a list\ndata: the value to insert in the field of the new node\nInput Format\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next lines contain an integer each, the elements to be inserted, one per function call.\nConstraints\nSample Input\n5\n383\n484\n392\n975\n321\nSample Output\n321\n975\n392\n484\n383\nExplanation\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "9": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node with the given integer as its attribute, insert this node at the desired position and return the head node.\nA position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.\nExample\nrefers to the first node in the list\n\nInsert a node at position with . The new list is\nFunction Description Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.\ninsertNodeAtPosition has the following parameters:\nhead: a SinglyLinkedListNode pointer to the head of the list\ndata: an integer value to insert as data in your new node\nposition: an integer position to insert the new node, zero based indexing\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer SinglyLinkedListNode[i].data.\nThe next line contains an integer , the data of the node that is to be inserted.\nThe last line contains an integer .\nConstraints\n, where is the element of the linked list.\n.\nSample Input\n3\n16\n13\n7\n1\n2\nSample Output\n16 13 1 7\nExplanation\nThe initial linked list is . Insert at the position which currently has in it. The updated linked list is .",
        "10": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nDelete the node at a given position in a linked list and return a reference to the head node. The head is at position 0. The list may be empty after you delete the node. In that case, return a null value.\nExample\n\nAfter removing the node at position , .\nFunction Description\nComplete the deleteNode function in the editor below.\ndeleteNode has the following parameters:\n- SinglyLinkedListNode pointer llist: a reference to the head node in the list\n- int position: the position of the node to remove\nReturns\n- SinglyLinkedListNode pointer: a reference to the head of the modified list\nInput Format\nThe first line of input contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the node data values in order.\nThe last line contains an integer, , the position of the node to delete.\nConstraints\n, where is the element of the linked list.\nSample Input\n8\n20\n6\n2\n19\n7\n4\n15\n9\n3\nSample Output\n20 6 2 7 4 15 9\nExplanation\nThe original list is . After deleting the node at position , the list is .",
        "11": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a singly-linked list, print each value from the reversed list. If the given list is empty, do not print anything.\nExample\nrefers to the linked list with values\nPrint the following:\n3\n2\n1\nFunction Description\nComplete the reversePrint function in the editor below.\nreversePrint has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nPrints\nThe values of each node in the reversed list.\nInput Format\nThe first line of input contains , the number of test cases.\nThe input of each test case is as follows:\nThe first line contains an integer , the number of elements in the list.\nEach of the next n lines contains a data element for a list node.\nConstraints\n, where is the element in the list.\nSample Input\n3\n5\n16\n12\n4\n2\n5\n3\n7\n3\n9\n5\n5\n1\n18\n3\n13\nSample Output\n5\n2\n4\n12\n16\n9\n3\n7\n13\n3\n18\n1\n5\nExplanation\nThere are three test cases. There are no blank lines between test case output.\nThe first linked list has elements: . Printing this in reverse order produces:\n5\n2\n4\n12\n16\nThe second linked list has elements: . Printing this in reverse order produces:\n9\n3\n7\nThe third linked list has elements: . Printing this in reverse order produces:\n13\n3\n18\n1\n5",
        "12": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\nExample\nreferences the list\nManipulate the pointers of each node in place and return , now referencing the head of the list .\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the values of the elements in the linked list.\nConstraints\n, where is the element in the list.\nSample Input\n1\n5\n1\n2\n3\n4\n5\nSample Output\n5 4 3 2 1 \nExplanation\nThe initial linked list is: .\nThe reversed linked list is: .",
        "13": "This challenge is part of a tutorial track by MyCodeSchool\nYou\u2019re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. If all data attributes are equal and the lists are the same length, return . Otherwise, return .\nExample\n\nThe two lists have equal data attributes for the first nodes. is longer, though, so the lists are not equal. Return .\nFunction Description\nComplete the compare_lists function in the editor below.\ncompare_lists has the following parameters:\nSinglyLinkedListNode llist1: a reference to the head of a list\nSinglyLinkedListNode llist2: a reference to the head of a list\nReturns\nint: return 1 if the lists are equal, or 0 otherwise\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test cases has the following format:\nThe first line contains an integer , the number of nodes in the first linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nThe next line contains an integer , the number of nodes in the second linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nConstraints\nOutput Format\nCompare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout\/console.\nThe output is handled by the code in the editor and it is as follows:\nFor each test case, in a new line, print if the two lists are equal, else print .\nSample Input\n2\n2\n1\n2\n1\n1\n2\n1\n2\n2\n1\n2\nSample Output\n0\n1\nExplanation\nThere are test cases, each with a pair of linked lists.\nIn the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL\nIn the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL",
        "14": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. Either head pointer may be null meaning that the corresponding list is empty.\nExample\nrefers to\nrefers to\nThe new list is\nFunction Description\nComplete the mergeLists function in the editor below.\nmergeLists has the following parameters:\nSinglyLinkedListNode pointer headA: a reference to the head of a list\nSinglyLinkedListNode pointer headB: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the merged list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the length of the first linked list.\nThe next lines contain an integer each, the elements of the linked list.\nThe next line contains an integer , the length of the second linked list.\nThe next lines contain an integer each, the elements of the second linked list.\nConstraints\n, where is the element of the list.\nSample Input\n1\n3\n1\n2\n3\n2\n3\n4\nSample Output\n1 2 3 3 4 \nExplanation\nThe first linked list is:\nThe second linked list is:\nHence, the merged linked list is:",
        "15": "This challenge is part of a tutorial track by MyCodeSchool\nGiven a pointer to the head of a linked list and a specific position, determine the data value at that position. Count backwards from the tail node. The tail is at postion 0, its parent is at 1 and so on.\nExample\nrefers to\nEach of the data values matches its distance from the tail. The value is at the desired position.\nFunction Description\nComplete the getNode function in the editor below.\ngetNode has the following parameters:\nSinglyLinkedListNode pointer head: refers to the head of the list\nint positionFromTail: the item to retrieve\nReturns\nint: the value at the desired position\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contains an integer, the data value for an element of the linked list.\nThe last line contains an integer , the position from the tail to retrieve the value of.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n1\n1\n0\n3\n3\n2\n1\n2\nSample Output\n1\n3\nExplanation\nIn the first case, there is one element in linked list with a value of 1. The last (only) element contains 1.\nIn the second case, the list is . The element with position of 2 from tail contains 3.",
        "16": "This challenge is part of a tutorial track by MyCodeSchool\nYou are given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete nodes and return a sorted list with each distinct value in the original list. The given head pointer may be null indicating that the list is empty.\nExample\nrefers to the first node in the list .\nRemove 1 of the data values and return pointing to the revised list .\nFunction Description\nComplete the removeDuplicates function in the editor below.\nremoveDuplicates has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the value for each of the elements of the linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n5       n = 5\n1       data values = 1, 2, 2, 3, 4\n2\n2\n3\n4\nSample Output\n1 2 3 4 \nExplanation\nThe initial linked list is: .\nThe final linked list is: .",
        "17": "A linked list is said to contain a cycle if any node is visited more than once while traversing the list. Given a pointer to the head of a linked list, determine if it contains a cycle. If it does, return . Otherwise, return .\nExample\nrefers to the list of nodes\nThe numbers shown are the node numbers, not their data values. There is no cycle in this list so return .\nrefers to the list of nodes\nThere is a cycle where node 3 points back to node 1, so return .\nFunction Description\nComplete the has_cycle function in the editor below.\nIt has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nint: if there is a cycle or if there is not\nNote: If the list is empty, will be null.\nInput Format\nThe code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity. Expand the section for the main function and review the code if you would like to figure out how to create a custom case.\nConstraints\nSample Input\nReferences to each of the following linked lists are passed as arguments to your function:\nSample Output\n0\n1\nExplanation\nThe first list has no cycle, so return .\nThe second list has a cycle, so return .",
        "18": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's value.\nNote: After the merge point, both lists will share the same node pointers.\nExample\nIn the diagram below, the two lists converge at Node x:\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     \/\n     [List #2] p--->q\nFunction Description\nComplete the findMergeNode function in the editor below.\nfindMergeNode has the following parameters:\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\nReturns\nint: the value of the node where the lists merge\nInput Format\nDo not read any input from stdin\/console.\nThe first line contains an integer , the number of test cases.\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer, that is the number of nodes in the first list.\nEach of the following lines contains a value for a node. The next line contains an integer, that is the number of nodes in the second list.\nEach of the following lines contains a value for a node.\nConstraints\nThe lists will merge.\n.\n.\nSample Input\nThe diagrams below are graphical representations of the lists that input nodes and are connected to.\nTest Case 0\n 1\n  \\\n   2--->3--->NULL\n  \/\n 1\nTest Case 1\n1--->2\n      \\\n       3--->Null\n      \/\n     1\nSample Output\n2\n3\nExplanation\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "19": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value and insert it at the proper location to maintain the sort.\nExample\nrefers to the list\nReturn a reference to the new list: .\nFunction Description\nComplete the sortedInsert function in the editor below.\nsortedInsert has two parameters:\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\nint data: An integer denoting the value of the field for the DoublyLinkedListNode you must insert into the list.\nReturns\nDoublyLinkedListNode pointer: a reference to the head of the list\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test case is in the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\nSample Output\n1 3 4 5 10\nExplanation\nThe initial doubly linked list is: .\nThe doubly linked list after insertion is:",
        "20": "An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index, (where ), that can be referenced as or .\nReverse an array of integers.\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\nExample\nReturn .\nFunction Description\nComplete the function reverseArray in the editor below.\nreverseArray has the following parameter(s):\nint A[n]: the array to reverse\nReturns\nint[n]: the reversed array\nInput Format\nThe first line contains an integer, , the number of integers in .\nThe second line contains space-separated integers that make up .\nConstraints",
        "21": "Given a 2D Array, :\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\nAn hourglass in is a subset of values with indices falling in this pattern in 's graphical representation:\na b c\n  d\ne f g\nThere are hourglasses in . An hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. The array will always be .\nExample\n-9 -9 -9  1 1 1 \n 0 -9  0  4 3 2\n-9 -9 -9  1 2 3\n 0  0  8  6 6 0\n 0  0  0 -2 0 0\n 0  0  1  2 4 0\nThe hourglass sums are:\n-63, -34, -9, 12, \n-10,   0, 28, 23, \n-27, -11, -2, 10, \n  9,  17, 25, 18\nThe highest hourglass sum is from the hourglass beginning at row , column :\n0 4 3\n  1\n8 6 6\nNote: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.\nFunction Description\nComplete the function hourglassSum in the editor below.\nhourglassSum has the following parameter(s):\nint arr[6][6]: an array of integers\nReturns\nint: the maximum hourglass sum\nInput Format\nEach of the lines of inputs contains space-separated integers .\nConstraints\nOutput Format\nPrint the largest (maximum) hourglass sum found in .\nSample Input\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 2 4 4 0\n0 0 0 2 0 0\n0 0 1 2 4 0\nSample Output\n19\nExplanation\ncontains the following hourglasses:\nThe hourglass with the maximum sum () is:\n2 4 4\n  2\n1 2 4",
        "22": "Declare a 2-dimensional array, , of empty arrays. All arrays are zero indexed.\nDeclare an integer, , and initialize it to .\nThere are types of queries, given as an array of strings for you to parse:\nQuery: 1 x y\nLet .\nAppend the integer to .\nQuery: 2 x y\nLet .\nAssign the value to .\nStore the new value of to an answers array.\nNote: is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. is the modulo operator.\nFinally, size(arr[idx]) is the number of elements in arr[idx]\nFunction Description\nComplete the dynamicArray function below.\ndynamicArray has the following parameters:\n- int n: the number of empty arrays to initialize in\n- string queries[q]: query strings that contain 3 space-separated integers\nReturns\nint[]: the results of each type 2 query in the order they are presented\nInput Format\nThe first line contains two space-separated integers, , the size of to create, and , the number of queries, respectively.\nEach of the subsequent lines contains a query string, .\nConstraints\nIt is guaranteed that query type will never query an empty array or index.\nSample Input\n2 5\n1 0 5\n1 1 7\n1 0 3\n2 1 0\n2 1 1\nSample Output\n7\n3\nExplanation\nInitial Values:\n\n\n= [ ]\n= [ ]\nQuery 0: Append to .\n\n= [5]\n= [ ]\nQuery 1: Append to .\n= [5]\n= [7]\nQuery 2: Append to .\n\n= [5, 3]\n= [7]\nQuery 3: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n7\nQuery 4: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n3",
        "23": "A left rotation operation on an array of size shifts each of the array's elements unit to the left. Given an integer, , rotate the array that many steps left and return the result.\nExample\n\nAfter rotations, .\nFunction Description\nComplete the rotateLeft function in the editor below.\nrotateLeft has the following parameters:\nint d: the amount to rotate by\nint arr[n]: the array to rotate\nReturns\nint[n]: the rotated array\nInput Format\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains space-separated integers that describe .\nConstraints\nSample Input\n5 4\n1 2 3 4 5\nSample Output\n5 1 2 3 4\nExplanation\nTo perform left rotations, the array undergoes the following sequence of changes:",
        "24": "There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.\nExample\n\nThere are instances of '', of '' and of ''. For each query, add an element to the return array, .\nFunction Description\nComplete the function matchingStrings in the editor below. The function must return an array of integers representing the frequency of occurrence of each query string in stringList.\nmatchingStrings has the following parameters:\nstring stringList[n] - an array of strings to search\nstring queries[q] - an array of query strings\nReturns\nint[q]: an array of results for each query\nInput Format\nThe first line contains and integer , the size of .\nEach of the next lines contains a string .\nThe next line contains , the size of .\nEach of the next lines contains a string .\nConstraints\n\n\n.",
        "25": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\nExample\n\nQueries are interpreted as follows:\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\nAdd the values of between the indices and inclusive:\nindex->  1 2 3  4  5 6 7 8 9 10\n [0,0,0, 0, 0,0,0,0,0, 0]\n [3,3,3, 3, 3,0,0,0,0, 0]\n [3,3,3,10,10,7,7,7,0, 0]\n [3,3,3,10,10,8,8,8,1, 0]\nThe largest value is after all operations are performed.\nFunction Description\nComplete the function arrayManipulation in the editor below.\narrayManipulation has the following parameters:\nint n - the number of elements in the array\nint queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.\nReturns\nint - the maximum value in the resultant array\nInput Format\nThe first line contains two space-separated integers and , the size of the array and the number of operations.\nEach of the next lines contains three space-separated integers , and , the left index, right index and summand.\nConstraints\nSample Input\n5 3\n1 2 100\n2 5 100\n3 4 100\nSample Output\n200\nExplanation\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\nThe maximum value is .",
        "26": "This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.\nThis is an to practice traversing a linked list. Given a pointer to the head node of a linked list, print each node's element, one per line. If the head pointer is null (indicating the list is empty), there is nothing to print.\nFunction Description\nComplete the printLinkedList function in the editor below.\nprintLinkedList has the following parameter(s):\nSinglyLinkedListNode head: a reference to the head of the list\nPrint\nFor each node, print its value on a new line (console.log in Javascript).\nInput Format\nThe first line of input contains , the number of elements in the linked list.\nThe next lines contain one element each, the values for each node.\nNote: Do not read any input from stdin\/console. Complete the printLinkedList function in the editor below.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n16\n13\nSample Output\n16\n13\nExplanation\nThere are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each on a new line.",
        "27": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nYou are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.\nFunction Description\nComplete the insertNodeAtTail function in the editor below.\ninsertNodeAtTail has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nint data: the data value for the node to insert\nReturns\nSinglyLinkedListNode pointer: reference to the head of the modified linked list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each, the value that needs to be inserted at tail.\nConstraints\nSample Input\nSTDIN Function ----- -------- 5 size of linked list n = 5 141 linked list data values 141..474 302 164 530 474\nSample Output\n141\n302\n164\n530\n474\nExplanation\nFirst the linked list is NULL. After inserting 141, the list is 141 -> NULL.\nAfter inserting 302, the list is 141 -> 302 -> NULL.\nAfter inserting 164, the list is 141 -> 302 -> 164 -> NULL.\nAfter inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.",
        "28": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a linked list, insert a new node before the head. The value in the new node should point to and the value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\nFunction Description\nComplete the function insertNodeAtHead in the editor below.\ninsertNodeAtHead has the following parameter(s):\nSinglyLinkedListNode llist: a reference to the head of a list\ndata: the value to insert in the field of the new node\nInput Format\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next lines contain an integer each, the elements to be inserted, one per function call.\nConstraints\nSample Input\n5\n383\n484\n392\n975\n321\nSample Output\n321\n975\n392\n484\n383\nExplanation\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "29": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node with the given integer as its attribute, insert this node at the desired position and return the head node.\nA position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.\nExample\nrefers to the first node in the list\n\nInsert a node at position with . The new list is\nFunction Description Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.\ninsertNodeAtPosition has the following parameters:\nhead: a SinglyLinkedListNode pointer to the head of the list\ndata: an integer value to insert as data in your new node\nposition: an integer position to insert the new node, zero based indexing\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer SinglyLinkedListNode[i].data.\nThe next line contains an integer , the data of the node that is to be inserted.\nThe last line contains an integer .\nConstraints\n, where is the element of the linked list.\n.\nSample Input\n3\n16\n13\n7\n1\n2\nSample Output\n16 13 1 7\nExplanation\nThe initial linked list is . Insert at the position which currently has in it. The updated linked list is .",
        "30": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nDelete the node at a given position in a linked list and return a reference to the head node. The head is at position 0. The list may be empty after you delete the node. In that case, return a null value.\nExample\n\nAfter removing the node at position , .\nFunction Description\nComplete the deleteNode function in the editor below.\ndeleteNode has the following parameters:\n- SinglyLinkedListNode pointer llist: a reference to the head node in the list\n- int position: the position of the node to remove\nReturns\n- SinglyLinkedListNode pointer: a reference to the head of the modified list\nInput Format\nThe first line of input contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the node data values in order.\nThe last line contains an integer, , the position of the node to delete.\nConstraints\n, where is the element of the linked list.\nSample Input\n8\n20\n6\n2\n19\n7\n4\n15\n9\n3\nSample Output\n20 6 2 7 4 15 9\nExplanation\nThe original list is . After deleting the node at position , the list is .",
        "31": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a singly-linked list, print each value from the reversed list. If the given list is empty, do not print anything.\nExample\nrefers to the linked list with values\nPrint the following:\n3\n2\n1\nFunction Description\nComplete the reversePrint function in the editor below.\nreversePrint has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nPrints\nThe values of each node in the reversed list.\nInput Format\nThe first line of input contains , the number of test cases.\nThe input of each test case is as follows:\nThe first line contains an integer , the number of elements in the list.\nEach of the next n lines contains a data element for a list node.\nConstraints\n, where is the element in the list.\nSample Input\n3\n5\n16\n12\n4\n2\n5\n3\n7\n3\n9\n5\n5\n1\n18\n3\n13\nSample Output\n5\n2\n4\n12\n16\n9\n3\n7\n13\n3\n18\n1\n5\nExplanation\nThere are three test cases. There are no blank lines between test case output.\nThe first linked list has elements: . Printing this in reverse order produces:\n5\n2\n4\n12\n16\nThe second linked list has elements: . Printing this in reverse order produces:\n9\n3\n7\nThe third linked list has elements: . Printing this in reverse order produces:\n13\n3\n18\n1\n5",
        "32": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\nExample\nreferences the list\nManipulate the pointers of each node in place and return , now referencing the head of the list .\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the values of the elements in the linked list.\nConstraints\n, where is the element in the list.\nSample Input\n1\n5\n1\n2\n3\n4\n5\nSample Output\n5 4 3 2 1 \nExplanation\nThe initial linked list is: .\nThe reversed linked list is: .",
        "33": "This challenge is part of a tutorial track by MyCodeSchool\nYou\u2019re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. If all data attributes are equal and the lists are the same length, return . Otherwise, return .\nExample\n\nThe two lists have equal data attributes for the first nodes. is longer, though, so the lists are not equal. Return .\nFunction Description\nComplete the compare_lists function in the editor below.\ncompare_lists has the following parameters:\nSinglyLinkedListNode llist1: a reference to the head of a list\nSinglyLinkedListNode llist2: a reference to the head of a list\nReturns\nint: return 1 if the lists are equal, or 0 otherwise\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test cases has the following format:\nThe first line contains an integer , the number of nodes in the first linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nThe next line contains an integer , the number of nodes in the second linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nConstraints\nOutput Format\nCompare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout\/console.\nThe output is handled by the code in the editor and it is as follows:\nFor each test case, in a new line, print if the two lists are equal, else print .\nSample Input\n2\n2\n1\n2\n1\n1\n2\n1\n2\n2\n1\n2\nSample Output\n0\n1\nExplanation\nThere are test cases, each with a pair of linked lists.\nIn the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL\nIn the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL",
        "34": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. Either head pointer may be null meaning that the corresponding list is empty.\nExample\nrefers to\nrefers to\nThe new list is\nFunction Description\nComplete the mergeLists function in the editor below.\nmergeLists has the following parameters:\nSinglyLinkedListNode pointer headA: a reference to the head of a list\nSinglyLinkedListNode pointer headB: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the merged list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the length of the first linked list.\nThe next lines contain an integer each, the elements of the linked list.\nThe next line contains an integer , the length of the second linked list.\nThe next lines contain an integer each, the elements of the second linked list.\nConstraints\n, where is the element of the list.\nSample Input\n1\n3\n1\n2\n3\n2\n3\n4\nSample Output\n1 2 3 3 4 \nExplanation\nThe first linked list is:\nThe second linked list is:\nHence, the merged linked list is:",
        "35": "This challenge is part of a tutorial track by MyCodeSchool\nGiven a pointer to the head of a linked list and a specific position, determine the data value at that position. Count backwards from the tail node. The tail is at postion 0, its parent is at 1 and so on.\nExample\nrefers to\nEach of the data values matches its distance from the tail. The value is at the desired position.\nFunction Description\nComplete the getNode function in the editor below.\ngetNode has the following parameters:\nSinglyLinkedListNode pointer head: refers to the head of the list\nint positionFromTail: the item to retrieve\nReturns\nint: the value at the desired position\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contains an integer, the data value for an element of the linked list.\nThe last line contains an integer , the position from the tail to retrieve the value of.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n1\n1\n0\n3\n3\n2\n1\n2\nSample Output\n1\n3\nExplanation\nIn the first case, there is one element in linked list with a value of 1. The last (only) element contains 1.\nIn the second case, the list is . The element with position of 2 from tail contains 3.",
        "36": "This challenge is part of a tutorial track by MyCodeSchool\nYou are given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete nodes and return a sorted list with each distinct value in the original list. The given head pointer may be null indicating that the list is empty.\nExample\nrefers to the first node in the list .\nRemove 1 of the data values and return pointing to the revised list .\nFunction Description\nComplete the removeDuplicates function in the editor below.\nremoveDuplicates has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the value for each of the elements of the linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n5       n = 5\n1       data values = 1, 2, 2, 3, 4\n2\n2\n3\n4\nSample Output\n1 2 3 4 \nExplanation\nThe initial linked list is: .\nThe final linked list is: .",
        "37": "A linked list is said to contain a cycle if any node is visited more than once while traversing the list. Given a pointer to the head of a linked list, determine if it contains a cycle. If it does, return . Otherwise, return .\nExample\nrefers to the list of nodes\nThe numbers shown are the node numbers, not their data values. There is no cycle in this list so return .\nrefers to the list of nodes\nThere is a cycle where node 3 points back to node 1, so return .\nFunction Description\nComplete the has_cycle function in the editor below.\nIt has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nint: if there is a cycle or if there is not\nNote: If the list is empty, will be null.\nInput Format\nThe code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity. Expand the section for the main function and review the code if you would like to figure out how to create a custom case.\nConstraints\nSample Input\nReferences to each of the following linked lists are passed as arguments to your function:\nSample Output\n0\n1\nExplanation\nThe first list has no cycle, so return .\nThe second list has a cycle, so return .",
        "38": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's value.\nNote: After the merge point, both lists will share the same node pointers.\nExample\nIn the diagram below, the two lists converge at Node x:\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     \/\n     [List #2] p--->q\nFunction Description\nComplete the findMergeNode function in the editor below.\nfindMergeNode has the following parameters:\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\nReturns\nint: the value of the node where the lists merge\nInput Format\nDo not read any input from stdin\/console.\nThe first line contains an integer , the number of test cases.\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer, that is the number of nodes in the first list.\nEach of the following lines contains a value for a node. The next line contains an integer, that is the number of nodes in the second list.\nEach of the following lines contains a value for a node.\nConstraints\nThe lists will merge.\n.\n.\nSample Input\nThe diagrams below are graphical representations of the lists that input nodes and are connected to.\nTest Case 0\n 1\n  \\\n   2--->3--->NULL\n  \/\n 1\nTest Case 1\n1--->2\n      \\\n       3--->Null\n      \/\n     1\nSample Output\n2\n3\nExplanation\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "39": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value and insert it at the proper location to maintain the sort.\nExample\nrefers to the list\nReturn a reference to the new list: .\nFunction Description\nComplete the sortedInsert function in the editor below.\nsortedInsert has two parameters:\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\nint data: An integer denoting the value of the field for the DoublyLinkedListNode you must insert into the list.\nReturns\nDoublyLinkedListNode pointer: a reference to the head of the list\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test case is in the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\nSample Output\n1 3 4 5 10\nExplanation\nThe initial doubly linked list is: .\nThe doubly linked list after insertion is:",
        "40": "This challenge is part of a tutorial track by MyCodeSchool\nGiven the pointer to the head node of a doubly linked list, reverse the order of the nodes in place. That is, change the next and prev pointers of the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.\nNote: The head node might be NULL to indicate that the list is empty.\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter(s):\nDoublyLinkedListNode head: a reference to the head of a DoublyLinkedList\nReturns\n- DoublyLinkedListNode: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case is of the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each denoting an element of the linked list.\nConstraints\nOutput Format\nReturn a reference to the head of your reversed list. The provided code will print the reverse array as a one line of space-separated integers for each test case.\nSample Input\n1\n4\n1\n2\n3\n4\nSample Output\n4 3 2 1 \nExplanation\nThe initial doubly linked list is:\nThe reversed doubly linked list is:",
        "41": "Complete the function in the editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the preOrder function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's preorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 4 6 \nExplanation\nThe preorder traversal of the binary tree is printed.",
        "42": "Complete the function in the editor below. It received parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's postorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4\nSample Output\n4 3 6 5 2 1 \nExplanation\nThe postorder traversal is shown.",
        "43": "In this challenge, you are required to implement inorder traversal of a tree.\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.\nInput Format\nOur hidden tester code passes the root node of a binary tree to your $inOrder* function.\nConstraints\nOutput Format\nPrint the tree's inorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 3 4 5 6 \nExplanation\nThe tree's inorder traversal results in as the required result.",
        "44": "The height of a binary tree is the number of edges between the tree's root and its furthest leaf. For example, the following binary tree is of height :\n\nFunction Description\nComplete the getHeight or height function in the editor. It must return the height of a binary tree as an integer.\ngetHeight or height has the following parameter(s):\nroot: a reference to the root of a binary tree.\nNote -The Height of binary tree with single node is taken as zero.\nInput Format\nThe first line contains an integer , the number of nodes in the tree.\nNext line contains space separated integer where th integer denotes node[i].data.\nNote: Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function. In a binary search tree, all nodes on the left branch of a node are less than the node value. All values on the right branch are greater than the node value.\nConstraints\n\nOutput Format\nYour function should return a single integer denoting the height of the binary tree.\nSample Input\nSample Output\n3\nExplanation\nThe longest root-to-leaf path is shown below:\nThere are nodes in this path that are connected by edges, meaning our binary tree's .",
        "45": "Given a pointer to the root of a binary tree, print the top view of the binary tree.\nThe tree as seen from the top the nodes, is called the top view of the tree.\nFor example :\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nTop View :\nComplete the function and print the resulting values on a single line separated by space.\nInput Format\nYou are given a function,\nvoid topView(node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values on a single line separated by space.\nSample Input\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nSample Output\n1 2 5 6\nExplanation\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nFrom the top, only nodes are visible.",
        "46": "Given a pointer to the root of a binary tree, you need to print the level order traversal of this tree. In level-order traversal, nodes are visited level by level from left to right. Complete the function and print the values in a single line separated by a space.\nFor example:\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nFor the above tree, the level order traversal is .\nInput Format\nYou are given a function,\nvoid levelOrder(Node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values in a single line separated by a space.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 6 4\nExplanation\nWe need to print the nodes level by level. We process each level from left to right.\nLevel Order Traversal: .",
        "47": "You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function.\nInput Format\nYou are given a function,\nNode * insert (Node * root ,int data) {\n\n}\nConstraints\nNo. of nodes in the tree 500\nOutput Format\nReturn the root of the binary search tree after inserting the value into the tree.\nSample Input\n        4\n       \/ \\\n      2   7\n     \/ \\\n    1   3\nThe value to be inserted is 6.\nSample Output\n         4\n       \/   \\\n      2     7\n     \/ \\   \/\n    1   3 6",
        "48": "Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit. If they are on the left side of the tree, they will be a 0 (zero). If on the right, they'll be a 1 (one). Only the leaves will contain a letter and its frequency count. All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.\nFor instance, consider the string ABRACADABRA. There are a total of characters in the string. This number should match the count in the ultimately determined root of the tree. Our frequencies are and . The two smallest frequencies are for and , both equal to , so we'll create a tree with them. The root node will contain the sum of the counts of its descendants, in this case . The left node will be the first character encountered, , and the right will contain . Next we have items with a character count of : the tree we just created, the character and the character . The tree came first, so it will go on the left of our new root node. will go on the right. Repeat until the tree is complete, then fill in the 's and 's for the edges. The finished graph looks like:\nInput characters are only present in the leaves. Internal nodes have a character value of \u03d5 (NULL). We can determine that our values for characters are:\nA - 0\nB - 111\nC - 1100\nD - 1101\nR - 10\nOur Huffman encoded string is:\nA B    R  A C     A D     A B    R  A\n0 111 10 0 1100 0 1101 0 111 10 0\nor\n01111001100011010111100\nTo avoid ambiguity, Huffman encoding is a prefix free encoding technique. No codeword appears as a prefix of any other codeword.\nTo decode the encoded string, follow the zeros and ones to a leaf and return the character there.\nYou are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.\nFunction Description\nComplete the function decode_huff in the editor below. It must return the decoded string.\ndecode_huff has the following parameters:\nroot: a reference to the root node of the Huffman tree\ns: a Huffman encoded string\nInput Format\nThere is one line of input containing the plain string, . Background code creates the Huffman tree then passes the head node and the encoded string to the function.\nConstraints\nOutput Format\nOutput the decoded string on a single line.\nSample Input\ns=\"1001011\"\nSample Output\nABACA\nExplanation\nS=\"1001011\"\nProcessing the string from left to right.\nS[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[1]='0' : we move to the left child. \nS[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.\nWe move back to the root.\n\nS[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[4]='0' : we move to the left child. \nS[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.\nWe move back to the root.\n\n S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nDecoded String = \"ABACA\"",
        "49": "You are given pointer to the root of the binary search tree and two values and . You need to return the lowest common ancestor (LCA) of and in the binary search tree.\n\nIn the diagram above, the lowest common ancestor of the nodes and is the node . Node is the lowest node which has nodes and as descendants.\nFunction Description\nComplete the function lca in the editor below. It should return a pointer to the lowest common ancestor node of the two values given.\nlca has the following parameters:\n- root: a pointer to the root node of a binary search tree\n- v1: a node.data value\n- v2: a node.data value\nInput Format\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers representing values.\nThe third line contains two space-separated integers, and .\nTo use the test data, you will have to create the binary search tree yourself. Here on the platform, the tree will be created for you.\nConstraints\n\n\n\nThe tree will contain nodes with data equal to and .\nOutput Format\nReturn the a pointer to the node that is the lowest common ancestor of and .\nSample Input\n6\n4 2 3 1 7 6\n1 7\nand .\nSample Output\n[reference to node 4]\nExplanation\nLCA of and is , the root in this case.\nReturn a pointer to the node.",
        "50": "An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index, (where ), that can be referenced as or .\nReverse an array of integers.\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\nExample\nReturn .\nFunction Description\nComplete the function reverseArray in the editor below.\nreverseArray has the following parameter(s):\nint A[n]: the array to reverse\nReturns\nint[n]: the reversed array\nInput Format\nThe first line contains an integer, , the number of integers in .\nThe second line contains space-separated integers that make up .\nConstraints",
        "51": "Given a 2D Array, :\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\nAn hourglass in is a subset of values with indices falling in this pattern in 's graphical representation:\na b c\n  d\ne f g\nThere are hourglasses in . An hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. The array will always be .\nExample\n-9 -9 -9  1 1 1 \n 0 -9  0  4 3 2\n-9 -9 -9  1 2 3\n 0  0  8  6 6 0\n 0  0  0 -2 0 0\n 0  0  1  2 4 0\nThe hourglass sums are:\n-63, -34, -9, 12, \n-10,   0, 28, 23, \n-27, -11, -2, 10, \n  9,  17, 25, 18\nThe highest hourglass sum is from the hourglass beginning at row , column :\n0 4 3\n  1\n8 6 6\nNote: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.\nFunction Description\nComplete the function hourglassSum in the editor below.\nhourglassSum has the following parameter(s):\nint arr[6][6]: an array of integers\nReturns\nint: the maximum hourglass sum\nInput Format\nEach of the lines of inputs contains space-separated integers .\nConstraints\nOutput Format\nPrint the largest (maximum) hourglass sum found in .\nSample Input\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 2 4 4 0\n0 0 0 2 0 0\n0 0 1 2 4 0\nSample Output\n19\nExplanation\ncontains the following hourglasses:\nThe hourglass with the maximum sum () is:\n2 4 4\n  2\n1 2 4",
        "52": "Declare a 2-dimensional array, , of empty arrays. All arrays are zero indexed.\nDeclare an integer, , and initialize it to .\nThere are types of queries, given as an array of strings for you to parse:\nQuery: 1 x y\nLet .\nAppend the integer to .\nQuery: 2 x y\nLet .\nAssign the value to .\nStore the new value of to an answers array.\nNote: is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. is the modulo operator.\nFinally, size(arr[idx]) is the number of elements in arr[idx]\nFunction Description\nComplete the dynamicArray function below.\ndynamicArray has the following parameters:\n- int n: the number of empty arrays to initialize in\n- string queries[q]: query strings that contain 3 space-separated integers\nReturns\nint[]: the results of each type 2 query in the order they are presented\nInput Format\nThe first line contains two space-separated integers, , the size of to create, and , the number of queries, respectively.\nEach of the subsequent lines contains a query string, .\nConstraints\nIt is guaranteed that query type will never query an empty array or index.\nSample Input\n2 5\n1 0 5\n1 1 7\n1 0 3\n2 1 0\n2 1 1\nSample Output\n7\n3\nExplanation\nInitial Values:\n\n\n= [ ]\n= [ ]\nQuery 0: Append to .\n\n= [5]\n= [ ]\nQuery 1: Append to .\n= [5]\n= [7]\nQuery 2: Append to .\n\n= [5, 3]\n= [7]\nQuery 3: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n7\nQuery 4: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n3",
        "53": "A left rotation operation on an array of size shifts each of the array's elements unit to the left. Given an integer, , rotate the array that many steps left and return the result.\nExample\n\nAfter rotations, .\nFunction Description\nComplete the rotateLeft function in the editor below.\nrotateLeft has the following parameters:\nint d: the amount to rotate by\nint arr[n]: the array to rotate\nReturns\nint[n]: the rotated array\nInput Format\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains space-separated integers that describe .\nConstraints\nSample Input\n5 4\n1 2 3 4 5\nSample Output\n5 1 2 3 4\nExplanation\nTo perform left rotations, the array undergoes the following sequence of changes:",
        "54": "There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.\nExample\n\nThere are instances of '', of '' and of ''. For each query, add an element to the return array, .\nFunction Description\nComplete the function matchingStrings in the editor below. The function must return an array of integers representing the frequency of occurrence of each query string in stringList.\nmatchingStrings has the following parameters:\nstring stringList[n] - an array of strings to search\nstring queries[q] - an array of query strings\nReturns\nint[q]: an array of results for each query\nInput Format\nThe first line contains and integer , the size of .\nEach of the next lines contains a string .\nThe next line contains , the size of .\nEach of the next lines contains a string .\nConstraints\n\n\n.",
        "55": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\nExample\n\nQueries are interpreted as follows:\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\nAdd the values of between the indices and inclusive:\nindex->  1 2 3  4  5 6 7 8 9 10\n [0,0,0, 0, 0,0,0,0,0, 0]\n [3,3,3, 3, 3,0,0,0,0, 0]\n [3,3,3,10,10,7,7,7,0, 0]\n [3,3,3,10,10,8,8,8,1, 0]\nThe largest value is after all operations are performed.\nFunction Description\nComplete the function arrayManipulation in the editor below.\narrayManipulation has the following parameters:\nint n - the number of elements in the array\nint queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.\nReturns\nint - the maximum value in the resultant array\nInput Format\nThe first line contains two space-separated integers and , the size of the array and the number of operations.\nEach of the next lines contains three space-separated integers , and , the left index, right index and summand.\nConstraints\nSample Input\n5 3\n1 2 100\n2 5 100\n3 4 100\nSample Output\n200\nExplanation\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\nThe maximum value is .",
        "56": "This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.\nThis is an to practice traversing a linked list. Given a pointer to the head node of a linked list, print each node's element, one per line. If the head pointer is null (indicating the list is empty), there is nothing to print.\nFunction Description\nComplete the printLinkedList function in the editor below.\nprintLinkedList has the following parameter(s):\nSinglyLinkedListNode head: a reference to the head of the list\nPrint\nFor each node, print its value on a new line (console.log in Javascript).\nInput Format\nThe first line of input contains , the number of elements in the linked list.\nThe next lines contain one element each, the values for each node.\nNote: Do not read any input from stdin\/console. Complete the printLinkedList function in the editor below.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n16\n13\nSample Output\n16\n13\nExplanation\nThere are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each on a new line.",
        "57": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nYou are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.\nFunction Description\nComplete the insertNodeAtTail function in the editor below.\ninsertNodeAtTail has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nint data: the data value for the node to insert\nReturns\nSinglyLinkedListNode pointer: reference to the head of the modified linked list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each, the value that needs to be inserted at tail.\nConstraints\nSample Input\nSTDIN Function ----- -------- 5 size of linked list n = 5 141 linked list data values 141..474 302 164 530 474\nSample Output\n141\n302\n164\n530\n474\nExplanation\nFirst the linked list is NULL. After inserting 141, the list is 141 -> NULL.\nAfter inserting 302, the list is 141 -> 302 -> NULL.\nAfter inserting 164, the list is 141 -> 302 -> 164 -> NULL.\nAfter inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.",
        "58": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a linked list, insert a new node before the head. The value in the new node should point to and the value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\nFunction Description\nComplete the function insertNodeAtHead in the editor below.\ninsertNodeAtHead has the following parameter(s):\nSinglyLinkedListNode llist: a reference to the head of a list\ndata: the value to insert in the field of the new node\nInput Format\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next lines contain an integer each, the elements to be inserted, one per function call.\nConstraints\nSample Input\n5\n383\n484\n392\n975\n321\nSample Output\n321\n975\n392\n484\n383\nExplanation\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "59": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node with the given integer as its attribute, insert this node at the desired position and return the head node.\nA position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.\nExample\nrefers to the first node in the list\n\nInsert a node at position with . The new list is\nFunction Description Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.\ninsertNodeAtPosition has the following parameters:\nhead: a SinglyLinkedListNode pointer to the head of the list\ndata: an integer value to insert as data in your new node\nposition: an integer position to insert the new node, zero based indexing\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer SinglyLinkedListNode[i].data.\nThe next line contains an integer , the data of the node that is to be inserted.\nThe last line contains an integer .\nConstraints\n, where is the element of the linked list.\n.\nSample Input\n3\n16\n13\n7\n1\n2\nSample Output\n16 13 1 7\nExplanation\nThe initial linked list is . Insert at the position which currently has in it. The updated linked list is .",
        "60": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nDelete the node at a given position in a linked list and return a reference to the head node. The head is at position 0. The list may be empty after you delete the node. In that case, return a null value.\nExample\n\nAfter removing the node at position , .\nFunction Description\nComplete the deleteNode function in the editor below.\ndeleteNode has the following parameters:\n- SinglyLinkedListNode pointer llist: a reference to the head node in the list\n- int position: the position of the node to remove\nReturns\n- SinglyLinkedListNode pointer: a reference to the head of the modified list\nInput Format\nThe first line of input contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the node data values in order.\nThe last line contains an integer, , the position of the node to delete.\nConstraints\n, where is the element of the linked list.\nSample Input\n8\n20\n6\n2\n19\n7\n4\n15\n9\n3\nSample Output\n20 6 2 7 4 15 9\nExplanation\nThe original list is . After deleting the node at position , the list is .",
        "61": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a singly-linked list, print each value from the reversed list. If the given list is empty, do not print anything.\nExample\nrefers to the linked list with values\nPrint the following:\n3\n2\n1\nFunction Description\nComplete the reversePrint function in the editor below.\nreversePrint has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nPrints\nThe values of each node in the reversed list.\nInput Format\nThe first line of input contains , the number of test cases.\nThe input of each test case is as follows:\nThe first line contains an integer , the number of elements in the list.\nEach of the next n lines contains a data element for a list node.\nConstraints\n, where is the element in the list.\nSample Input\n3\n5\n16\n12\n4\n2\n5\n3\n7\n3\n9\n5\n5\n1\n18\n3\n13\nSample Output\n5\n2\n4\n12\n16\n9\n3\n7\n13\n3\n18\n1\n5\nExplanation\nThere are three test cases. There are no blank lines between test case output.\nThe first linked list has elements: . Printing this in reverse order produces:\n5\n2\n4\n12\n16\nThe second linked list has elements: . Printing this in reverse order produces:\n9\n3\n7\nThe third linked list has elements: . Printing this in reverse order produces:\n13\n3\n18\n1\n5",
        "62": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\nExample\nreferences the list\nManipulate the pointers of each node in place and return , now referencing the head of the list .\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the values of the elements in the linked list.\nConstraints\n, where is the element in the list.\nSample Input\n1\n5\n1\n2\n3\n4\n5\nSample Output\n5 4 3 2 1 \nExplanation\nThe initial linked list is: .\nThe reversed linked list is: .",
        "63": "This challenge is part of a tutorial track by MyCodeSchool\nYou\u2019re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. If all data attributes are equal and the lists are the same length, return . Otherwise, return .\nExample\n\nThe two lists have equal data attributes for the first nodes. is longer, though, so the lists are not equal. Return .\nFunction Description\nComplete the compare_lists function in the editor below.\ncompare_lists has the following parameters:\nSinglyLinkedListNode llist1: a reference to the head of a list\nSinglyLinkedListNode llist2: a reference to the head of a list\nReturns\nint: return 1 if the lists are equal, or 0 otherwise\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test cases has the following format:\nThe first line contains an integer , the number of nodes in the first linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nThe next line contains an integer , the number of nodes in the second linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nConstraints\nOutput Format\nCompare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout\/console.\nThe output is handled by the code in the editor and it is as follows:\nFor each test case, in a new line, print if the two lists are equal, else print .\nSample Input\n2\n2\n1\n2\n1\n1\n2\n1\n2\n2\n1\n2\nSample Output\n0\n1\nExplanation\nThere are test cases, each with a pair of linked lists.\nIn the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL\nIn the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL",
        "64": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. Either head pointer may be null meaning that the corresponding list is empty.\nExample\nrefers to\nrefers to\nThe new list is\nFunction Description\nComplete the mergeLists function in the editor below.\nmergeLists has the following parameters:\nSinglyLinkedListNode pointer headA: a reference to the head of a list\nSinglyLinkedListNode pointer headB: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the merged list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the length of the first linked list.\nThe next lines contain an integer each, the elements of the linked list.\nThe next line contains an integer , the length of the second linked list.\nThe next lines contain an integer each, the elements of the second linked list.\nConstraints\n, where is the element of the list.\nSample Input\n1\n3\n1\n2\n3\n2\n3\n4\nSample Output\n1 2 3 3 4 \nExplanation\nThe first linked list is:\nThe second linked list is:\nHence, the merged linked list is:",
        "65": "This challenge is part of a tutorial track by MyCodeSchool\nGiven a pointer to the head of a linked list and a specific position, determine the data value at that position. Count backwards from the tail node. The tail is at postion 0, its parent is at 1 and so on.\nExample\nrefers to\nEach of the data values matches its distance from the tail. The value is at the desired position.\nFunction Description\nComplete the getNode function in the editor below.\ngetNode has the following parameters:\nSinglyLinkedListNode pointer head: refers to the head of the list\nint positionFromTail: the item to retrieve\nReturns\nint: the value at the desired position\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contains an integer, the data value for an element of the linked list.\nThe last line contains an integer , the position from the tail to retrieve the value of.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n1\n1\n0\n3\n3\n2\n1\n2\nSample Output\n1\n3\nExplanation\nIn the first case, there is one element in linked list with a value of 1. The last (only) element contains 1.\nIn the second case, the list is . The element with position of 2 from tail contains 3.",
        "66": "This challenge is part of a tutorial track by MyCodeSchool\nYou are given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete nodes and return a sorted list with each distinct value in the original list. The given head pointer may be null indicating that the list is empty.\nExample\nrefers to the first node in the list .\nRemove 1 of the data values and return pointing to the revised list .\nFunction Description\nComplete the removeDuplicates function in the editor below.\nremoveDuplicates has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the value for each of the elements of the linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n5       n = 5\n1       data values = 1, 2, 2, 3, 4\n2\n2\n3\n4\nSample Output\n1 2 3 4 \nExplanation\nThe initial linked list is: .\nThe final linked list is: .",
        "67": "A linked list is said to contain a cycle if any node is visited more than once while traversing the list. Given a pointer to the head of a linked list, determine if it contains a cycle. If it does, return . Otherwise, return .\nExample\nrefers to the list of nodes\nThe numbers shown are the node numbers, not their data values. There is no cycle in this list so return .\nrefers to the list of nodes\nThere is a cycle where node 3 points back to node 1, so return .\nFunction Description\nComplete the has_cycle function in the editor below.\nIt has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nint: if there is a cycle or if there is not\nNote: If the list is empty, will be null.\nInput Format\nThe code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity. Expand the section for the main function and review the code if you would like to figure out how to create a custom case.\nConstraints\nSample Input\nReferences to each of the following linked lists are passed as arguments to your function:\nSample Output\n0\n1\nExplanation\nThe first list has no cycle, so return .\nThe second list has a cycle, so return .",
        "68": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's value.\nNote: After the merge point, both lists will share the same node pointers.\nExample\nIn the diagram below, the two lists converge at Node x:\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     \/\n     [List #2] p--->q\nFunction Description\nComplete the findMergeNode function in the editor below.\nfindMergeNode has the following parameters:\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\nReturns\nint: the value of the node where the lists merge\nInput Format\nDo not read any input from stdin\/console.\nThe first line contains an integer , the number of test cases.\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer, that is the number of nodes in the first list.\nEach of the following lines contains a value for a node. The next line contains an integer, that is the number of nodes in the second list.\nEach of the following lines contains a value for a node.\nConstraints\nThe lists will merge.\n.\n.\nSample Input\nThe diagrams below are graphical representations of the lists that input nodes and are connected to.\nTest Case 0\n 1\n  \\\n   2--->3--->NULL\n  \/\n 1\nTest Case 1\n1--->2\n      \\\n       3--->Null\n      \/\n     1\nSample Output\n2\n3\nExplanation\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "69": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value and insert it at the proper location to maintain the sort.\nExample\nrefers to the list\nReturn a reference to the new list: .\nFunction Description\nComplete the sortedInsert function in the editor below.\nsortedInsert has two parameters:\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\nint data: An integer denoting the value of the field for the DoublyLinkedListNode you must insert into the list.\nReturns\nDoublyLinkedListNode pointer: a reference to the head of the list\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test case is in the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\nSample Output\n1 3 4 5 10\nExplanation\nThe initial doubly linked list is: .\nThe doubly linked list after insertion is:",
        "70": "This challenge is part of a tutorial track by MyCodeSchool\nGiven the pointer to the head node of a doubly linked list, reverse the order of the nodes in place. That is, change the next and prev pointers of the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.\nNote: The head node might be NULL to indicate that the list is empty.\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter(s):\nDoublyLinkedListNode head: a reference to the head of a DoublyLinkedList\nReturns\n- DoublyLinkedListNode: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case is of the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each denoting an element of the linked list.\nConstraints\nOutput Format\nReturn a reference to the head of your reversed list. The provided code will print the reverse array as a one line of space-separated integers for each test case.\nSample Input\n1\n4\n1\n2\n3\n4\nSample Output\n4 3 2 1 \nExplanation\nThe initial doubly linked list is:\nThe reversed doubly linked list is:",
        "71": "Complete the function in the editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the preOrder function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's preorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 4 6 \nExplanation\nThe preorder traversal of the binary tree is printed.",
        "72": "Complete the function in the editor below. It received parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's postorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4\nSample Output\n4 3 6 5 2 1 \nExplanation\nThe postorder traversal is shown.",
        "73": "In this challenge, you are required to implement inorder traversal of a tree.\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.\nInput Format\nOur hidden tester code passes the root node of a binary tree to your $inOrder* function.\nConstraints\nOutput Format\nPrint the tree's inorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 3 4 5 6 \nExplanation\nThe tree's inorder traversal results in as the required result.",
        "74": "The height of a binary tree is the number of edges between the tree's root and its furthest leaf. For example, the following binary tree is of height :\n\nFunction Description\nComplete the getHeight or height function in the editor. It must return the height of a binary tree as an integer.\ngetHeight or height has the following parameter(s):\nroot: a reference to the root of a binary tree.\nNote -The Height of binary tree with single node is taken as zero.\nInput Format\nThe first line contains an integer , the number of nodes in the tree.\nNext line contains space separated integer where th integer denotes node[i].data.\nNote: Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function. In a binary search tree, all nodes on the left branch of a node are less than the node value. All values on the right branch are greater than the node value.\nConstraints\n\nOutput Format\nYour function should return a single integer denoting the height of the binary tree.\nSample Input\nSample Output\n3\nExplanation\nThe longest root-to-leaf path is shown below:\nThere are nodes in this path that are connected by edges, meaning our binary tree's .",
        "75": "Given a pointer to the root of a binary tree, print the top view of the binary tree.\nThe tree as seen from the top the nodes, is called the top view of the tree.\nFor example :\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nTop View :\nComplete the function and print the resulting values on a single line separated by space.\nInput Format\nYou are given a function,\nvoid topView(node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values on a single line separated by space.\nSample Input\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nSample Output\n1 2 5 6\nExplanation\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nFrom the top, only nodes are visible.",
        "76": "Given a pointer to the root of a binary tree, you need to print the level order traversal of this tree. In level-order traversal, nodes are visited level by level from left to right. Complete the function and print the values in a single line separated by a space.\nFor example:\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nFor the above tree, the level order traversal is .\nInput Format\nYou are given a function,\nvoid levelOrder(Node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values in a single line separated by a space.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 6 4\nExplanation\nWe need to print the nodes level by level. We process each level from left to right.\nLevel Order Traversal: .",
        "77": "You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function.\nInput Format\nYou are given a function,\nNode * insert (Node * root ,int data) {\n\n}\nConstraints\nNo. of nodes in the tree 500\nOutput Format\nReturn the root of the binary search tree after inserting the value into the tree.\nSample Input\n        4\n       \/ \\\n      2   7\n     \/ \\\n    1   3\nThe value to be inserted is 6.\nSample Output\n         4\n       \/   \\\n      2     7\n     \/ \\   \/\n    1   3 6",
        "78": "Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit. If they are on the left side of the tree, they will be a 0 (zero). If on the right, they'll be a 1 (one). Only the leaves will contain a letter and its frequency count. All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.\nFor instance, consider the string ABRACADABRA. There are a total of characters in the string. This number should match the count in the ultimately determined root of the tree. Our frequencies are and . The two smallest frequencies are for and , both equal to , so we'll create a tree with them. The root node will contain the sum of the counts of its descendants, in this case . The left node will be the first character encountered, , and the right will contain . Next we have items with a character count of : the tree we just created, the character and the character . The tree came first, so it will go on the left of our new root node. will go on the right. Repeat until the tree is complete, then fill in the 's and 's for the edges. The finished graph looks like:\nInput characters are only present in the leaves. Internal nodes have a character value of \u03d5 (NULL). We can determine that our values for characters are:\nA - 0\nB - 111\nC - 1100\nD - 1101\nR - 10\nOur Huffman encoded string is:\nA B    R  A C     A D     A B    R  A\n0 111 10 0 1100 0 1101 0 111 10 0\nor\n01111001100011010111100\nTo avoid ambiguity, Huffman encoding is a prefix free encoding technique. No codeword appears as a prefix of any other codeword.\nTo decode the encoded string, follow the zeros and ones to a leaf and return the character there.\nYou are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.\nFunction Description\nComplete the function decode_huff in the editor below. It must return the decoded string.\ndecode_huff has the following parameters:\nroot: a reference to the root node of the Huffman tree\ns: a Huffman encoded string\nInput Format\nThere is one line of input containing the plain string, . Background code creates the Huffman tree then passes the head node and the encoded string to the function.\nConstraints\nOutput Format\nOutput the decoded string on a single line.\nSample Input\ns=\"1001011\"\nSample Output\nABACA\nExplanation\nS=\"1001011\"\nProcessing the string from left to right.\nS[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[1]='0' : we move to the left child. \nS[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.\nWe move back to the root.\n\nS[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[4]='0' : we move to the left child. \nS[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.\nWe move back to the root.\n\n S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nDecoded String = \"ABACA\"",
        "79": "You are given pointer to the root of the binary search tree and two values and . You need to return the lowest common ancestor (LCA) of and in the binary search tree.\n\nIn the diagram above, the lowest common ancestor of the nodes and is the node . Node is the lowest node which has nodes and as descendants.\nFunction Description\nComplete the function lca in the editor below. It should return a pointer to the lowest common ancestor node of the two values given.\nlca has the following parameters:\n- root: a pointer to the root node of a binary search tree\n- v1: a node.data value\n- v2: a node.data value\nInput Format\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers representing values.\nThe third line contains two space-separated integers, and .\nTo use the test data, you will have to create the binary search tree yourself. Here on the platform, the tree will be created for you.\nConstraints\n\n\n\nThe tree will contain nodes with data equal to and .\nOutput Format\nReturn the a pointer to the node that is the lowest common ancestor of and .\nSample Input\n6\n4 2 3 1 7 6\n1 7\nand .\nSample Output\n[reference to node 4]\nExplanation\nLCA of and is , the root in this case.\nReturn a pointer to the node.",
        "80": "A binary tree is a tree which is characterized by one of the following properties:\nIt can be empty (null).\nIt contains a root node only.\nIt contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees.\nIn-order traversal is performed as\nTraverse the left subtree.\nVisit root.\nTraverse the right subtree.\nFor this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf. When you reach a leaf, back up to its parent, check for a right child and visit it if there is one. If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner. Keep doing this until you have traversed the entire tree. You will only store the values of a node as you visit when one of the following is true:\nit is the first node visited, the first time visited\nit is a leaf, should only be visited once\nall of its subtrees have been explored, should only be visited once while this is true\nit is the root of the tree, the first time visited\nSwapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L.\nFor example, in the following tree, we swap children of node 1.\n                                Depth\n    1               1            [1]\n   \/ \\             \/ \\\n  2   3     ->    3   2          [2]\n   \\   \\           \\   \\\n    4   5           5   4        [3]\nIn-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4.\nSwap operation:\nWe define depth of a node as follows:\nThe root node is at depth 1.\nIf the depth of the parent node is d, then the depth of current node will be d+1.\nGiven a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h \u2208 [k, 2k, 3k,...]. In other words, if h is a multiple of k, swap the left and right subtrees of that level.\nYou are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree.\nFunction Description\nComplete the swapNodes function in the editor below. It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation.\nswapNodes has the following parameter(s):\n- indexes: an array of integers representing index values of each , beginning with , the first element, as the root.\n- queries: an array of integers, each representing a value.\nInput Format\nThe first line contains n, number of nodes in the tree.\nEach of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.\nNote: -1 is used to represent a null node.\nThe next line contains an integer, t, the size of .\nEach of the next t lines contains an integer , each being a value .\nOutput Format\nFor each k, perform the swap operation and store the indices of your in-order traversal to your result array. After all swap operations have been performed, return your result array for printing.\nConstraints\nEither or\nEither or\nThe index of a non-null child will always be greater than that of its parent.\nSample Input 0\n3\n2 3\n-1 -1\n-1 -1\n2\n1\n1\nSample Output 0\n3 1 2\n2 1 3\nExplanation 0\nAs nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.\n    1   [s]       1    [s]       1   \n   \/ \\      ->   \/ \\        ->  \/ \\  \n  2   3 [s]     3   2  [s]     2   3\nNote: [s] indicates that a swap operation is done at this depth.\nSample Input 1\n5\n2 3\n-1 4\n-1 5\n-1 -1\n-1 -1\n1\n2\nSample Output 1\n4 2 1 5 3\nExplanation 1\nSwapping child nodes of node 2 and 3 we get\n    1                  1  \n   \/ \\                \/ \\ \n  2   3   [s]  ->    2   3\n   \\   \\            \/   \/ \n    4   5          4   5  \nSample Input 2\n11\n2 3\n4 -1\n5 -1\n6 -1\n7 8\n-1 9\n-1 -1\n10 11\n-1 -1\n-1 -1\n-1 -1\n2\n2\n4\nSample Output 2\n2 9 6 4 1 3 7 5 11 8 10\n2 6 9 4 1 3 7 5 10 8 11\nExplanation 2\nHere we perform swap operations at the nodes whose depth is either 2 or 4 for and then at nodes whose depth is 4 for .\n         1                     1                          1             \n        \/ \\                   \/ \\                        \/ \\            \n       \/   \\                 \/   \\                      \/   \\           \n      2     3    [s]        2     3                    2     3          \n     \/      \/                \\     \\                    \\     \\         \n    \/      \/                  \\     \\                    \\     \\        \n   4      5          ->        4     5          ->        4     5       \n  \/      \/ \\                  \/     \/ \\                  \/     \/ \\      \n \/      \/   \\                \/     \/   \\                \/     \/   \\     \n6      7     8   [s]        6     7     8   [s]        6     7     8\n \\          \/ \\            \/           \/ \\              \\         \/ \\   \n  \\        \/   \\          \/           \/   \\              \\       \/   \\  \n   9      10   11        9           11   10              9     10   11 ",
        "81": "Kitty has a tree, , consisting of nodes where each node is uniquely labeled from to . Her friend Alex gave her sets, where each set contains distinct nodes. Kitty needs to calculate the following expression on each set:\nwhere:\ndenotes an unordered pair of nodes belonging to the set.\ndenotes the number of edges on the unique (shortest) path between nodes and .\nGiven and sets of distinct nodes, calculate the expression for each set. For each set of nodes, print the value of the expression modulo on a new line.\nExample\n\nThe graph looks like this:\n\nThere are three pairs that can be created from the query set: . The distance from to is , from to is , and from to is .\nNow do the summation:\nInput Format\nThe first line contains two space-separated integers, the respective values of (the number of nodes in tree ) and (the number of nodes in the query set).\nEach of the subsequent lines contains two space-separated integers, and , that describe an undirected edge between nodes and .\nThe subsequent lines define each set over two lines in the following format:\nThe first line contains an integer, , the size of the set.\nThe second line contains space-separated integers, the set's elements.\nConstraints\nThe sum of over all does not exceed .\nAll elements in each set are distinct.\nSubtasks\nfor of the maximum score.\nfor of the maximum score.\nfor of the maximum score.\nOutput Format\nPrint lines of output where each line contains the expression for the query, modulo .\nSample Input 0\n7 3\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n2\n2 4\n1\n5\n3\n2 4 5\nSample Output 0\n16\n0\n106\nExplanation 0\nTree looks like this:\nWe perform the following calculations for sets:\nSet : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:\nSet : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print on a new line.\nSet : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:",
        "82": "For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements:\nThe value of every node in a node's left subtree is less than the data value of that node.\nThe value of every node in a node's right subtree is greater than the data value of that node.\nGiven the root node of a binary tree, can you determine if it's also a binary search tree?\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.\nInput Format\nYou are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument.\nConstraints\nOutput Format\nYou are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line.\nSample Input\nSample Output\nNo",
        "83": "The square-ten tree decomposition of an array is defined as follows:\nThe lowest () level of the square-ten tree consists of single array elements in their natural order.\nThe level (starting from ) of the square-ten tree consists of subsequent array subsegments of length in their natural order. Thus, the level contains subsegments of length , the level contains subsegments of length , the level contains subsegments of length , etc.\nIn other words, every level (for every ) of square-ten tree consists of array subsegments indexed as:\nLevel consists of array subsegments indexed as .\nThe image below depicts the bottom-left corner (i.e., the first array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:\nTask\nGiven the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence such as for every , , , where every belongs to any of the square-ten tree levels and is minimal amongst all such variants.\nInput Format\nThe first line contains a single integer denoting .\nThe second line contains a single integer denoting .\nConstraints\nThe numbers in input do not contain leading zeroes.\nOutput Format\nAs soon as array indices are too large, you should find a sequence of square-ten tree level numbers, , meaning that subsegment belongs to the level of the square-ten tree.\nPrint this sequence in the following compressed format:\nOn the first line, print the value of (i.e., the compressed sequence block count).\nFor each of the subsequent lines, print space-separated integers, and (, ), meaning that the number appears consequently times in sequence . Blocks should be listed in the order they appear in the sequence. In other words, should be equal to , should be equal to , etc.\nThus must be true and must be true for every . All numbers should be printed without leading zeroes.\nSample Input 0\n1\n10\nSample Output 0\n1\n1 1\nExplanation 0\nSegment belongs to level of the square-ten tree.",
        "84": "Greg has a tree of nodes containing integer data. He wants to insert a node with some non-zero integer value somewhere into the tree. His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount. This is called a balanced forest. Being frugal, the data value he inserts should be minimal. Determine the minimal amount that a new node can have to allow creation of a balanced forest. If it's not possible to create a balanced forest, return -1.\nFor example, you are given node values and . It is the following tree:\nThe blue node is root, the first number in a node is node number and the second is its value. Cuts can be made between nodes and and nodes and to have three trees with sums , and . Adding a new node of to the third tree completes the solution.\nFunction Description\nComplete the balancedForest function in the editor below. It must return an integer representing the minimum value of that can be added to allow creation of a balanced forest, or if it is not possible.\nbalancedForest has the following parameter(s):\nc: an array of integers, the data values for each node\nedges: an array of 2 element arrays, the node pairs per edge\nInput Format\nThe first line contains a single integer, , the number of queries.\nEach of the following sets of lines is as follows:\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers describing the respective values of , where each denotes the value at node .\nEach of the following lines contains two space-separated integers, and , describing edge connecting nodes and .\nConstraints\nEach query forms a valid undirected tree.\nSubtasks\nFor of the maximum score:\nFor of the maximum score:\nOutput Format\nFor each query, return the minimum value of the integer . If no such value exists, return instead.\nSample Input\n2\n5\n1 2 2 1 1\n1 2\n1 3\n3 5\n1 4\n3\n1 3 5\n1 3\n1 2\nSample Output\n2\n-1\nExplanation\nWe perform the following two queries:\nThe tree initially looks like this:\n\nGreg can add a new node with and create a new edge connecting nodes and . Then he cuts the edge connecting nodes and and the edge connecting nodes and . We now have a three-tree balanced forest where each tree has a sum of .\nIn the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .",
        "85": "Jenny loves experimenting with trees. Her favorite tree has nodes connected by edges, and each edge is unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius from this tree by performing the following two steps:\nChoose a node, , from the tree.\nCut a subtree consisting of all nodes which are not further than units from node .\nFor example, the blue nodes in the diagram below depict a subtree centered at that has radius :\nGiven , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not isomorphic.\nInput Format\nThe first line contains two space-separated integers denoting the respective values of and .\nEach of the next subsequent lines contains two space-separated integers, and , describing a bidirectional edge in Jenny's tree having length .\nConstraints\nSubtasks\nFor of the max score:\nOutput Format\nPrint the total number of different possible subtrees.\nSample Input 0\n7 1\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\nSample Output 0\n3\nExplanation 0\nIn the diagram below, blue nodes denote the possible subtrees:\nThe last subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print as our answer.\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\nSample Output 1\n4\nExplanation 1\nIn the diagram below, blue nodes denote the possible subtrees:\nHere, we have four possible different subtrees.",
        "86": "We consider metric space to be a pair, , where is a set and such that the following conditions hold:\nwhere is the distance between points and .\nLet's define the product of two metric spaces, , to be such that:\n, where , .\nSo, it follows logically that is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: .\nFor example, , where is a metric space. , where .\nIn this challenge, we need a tree-space. You're given a tree, , where is the set of vertices and is the set of edges. Let the function be the distance between two vertices in tree (i.e., is the number of edges on the path between vertices and ). Note that is a metric space.\nYou are given a tree, , with vertices, as well as points in . Find and print the distance between the two furthest points in this metric space!\nInput Format\nThe first line contains two space-separated positive integers describing the respective values of (the number of vertices in ) and (the number of given points).\nEach line of the subsequent lines contains two space-separated integers, and , describing edge in .\nEach line of the subsequent lines contains two space-separated integers describing the respective values of and for point .\nConstraints\nScoring\nThis challenge uses binary scoring, so you must pass all test cases to earn a positive score.\nOutput Format\nPrint a single non-negative integer denoting the maximum distance between two of the given points in metric space .\nSample Input 0\n2 2\n1 2\n1 2\n2 1\nSample Output 0\n2\nExplanation 0\nThe distance between points and is .\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n3 6\n4 5\n5 5\nSample Output 1\n3\nExplanation 1\nThe best points are and , which gives us a distance of .",
        "87": "Consider an array of integers, . Find and print the total number of pairs such that where .\nInput Format\nThe first line contains an integer, , denoting the number of elements in the array.\nThe second line consists of space-separated integers describing the respective values of .\nConstraints\nScoring\nfor of the test cases.\nfor of the test cases.\nfor of the test cases.\nOutput Format\nPrint a long integer denoting the total number pairs satisfying where .\nSample Input\n5  \n1 1 2 4 2\nSample Output\n8\nExplanation\nThere are eight pairs of indices satisfying the given criteria: , , , , , , , and . Thus, we print as our answer.",
        "88": "An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.\nWe define balance factor for each node as :\nbalanceFactor = height(left subtree) - height(right subtree)\nThe balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than \u22121 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.\n(https:\/\/en.wikipedia.org\/wiki\/AVL_tree)\nYou are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.\nInput Format\nYou are given a function,\nnode *insert(node * root,int new_val)\n{\n\n\n}\n'node' is defined as :\nstruct node\n{\nint val;            \/\/value\nstruct node* left;  \/\/left child\nstruct node* right; \/\/right child\nint ht;             \/\/height of the node\n} node;\nYou only need to complete the function.\nNote: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.\n\nOutput Format\nInsert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced.\nSample Input\n    3\n  \/  \\\n 2    4\n       \\\n        5\nThe value to be inserted is 6.\nSample Output\n    3\n  \/  \\\n 2    5\n     \/ \\\n    4   6\nExplanation\nAfter inserting 6 in the tree. the tree becomes:\n    3 (Balance Factor = -2)\n  \/  \\\n 2    4 (Balance Factor = -2)\n       \\\n        5 (Balance Factor = -1)\n         \\\n          6 (Balance Factor = 0)\nBalance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree.\nAfter performing the rotation, the tree becomes :\n                              3 (Balance Factor = -1)\n                            \/   \\\n      (Balance Factor = 0) 2     5 (Balance Factor = 0)\n                                \/ \\\n           (Balance Factor = 0)4   6 (Balance Factor = 0)",
        "89": "Given two numbers and . indicates the number of elements in the array and indicates number of queries. You need to perform two types of queries on the array .\nYou are given queries. Queries can be of two types, type 1 and type 2.\nType 1 queries are represented as 1 i j : Modify the given array by removing elements from to and adding them to the front.\nType 2 queries are represented as 2 i j : Modify the given array by removing elements from to and adding them to the back.\nYour task is to simply print of the resulting array after the execution of queries followed by the resulting array.\nNote While adding at back or front the order of elements is preserved.\nInput Format\nFirst line consists of two space-separated integers, and .\nSecond line contains integers, which represent the elements of the array.\nqueries follow. Each line contains a query of either type 1 or type 2 in the form\nConstraints\n\n\nOutput Format\nPrint the absolute value i.e. in the first line.\nPrint elements of the resulting array in the second line. Each element should be seperated by a single space.\nSample Input\n8 4\n1 2 3 4 5 6 7 8\n1 2 4\n2 3 5\n1 4 7\n2 1 4\nSample Output\n1\n2 3 6 5 7 8 4 1\nExplanation\nGiven array is .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nNow is i.e. and the array is",
        "90": "An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index, (where ), that can be referenced as or .\nReverse an array of integers.\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\nExample\nReturn .\nFunction Description\nComplete the function reverseArray in the editor below.\nreverseArray has the following parameter(s):\nint A[n]: the array to reverse\nReturns\nint[n]: the reversed array\nInput Format\nThe first line contains an integer, , the number of integers in .\nThe second line contains space-separated integers that make up .\nConstraints",
        "91": "Given a 2D Array, :\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\nAn hourglass in is a subset of values with indices falling in this pattern in 's graphical representation:\na b c\n  d\ne f g\nThere are hourglasses in . An hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. The array will always be .\nExample\n-9 -9 -9  1 1 1 \n 0 -9  0  4 3 2\n-9 -9 -9  1 2 3\n 0  0  8  6 6 0\n 0  0  0 -2 0 0\n 0  0  1  2 4 0\nThe hourglass sums are:\n-63, -34, -9, 12, \n-10,   0, 28, 23, \n-27, -11, -2, 10, \n  9,  17, 25, 18\nThe highest hourglass sum is from the hourglass beginning at row , column :\n0 4 3\n  1\n8 6 6\nNote: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.\nFunction Description\nComplete the function hourglassSum in the editor below.\nhourglassSum has the following parameter(s):\nint arr[6][6]: an array of integers\nReturns\nint: the maximum hourglass sum\nInput Format\nEach of the lines of inputs contains space-separated integers .\nConstraints\nOutput Format\nPrint the largest (maximum) hourglass sum found in .\nSample Input\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 2 4 4 0\n0 0 0 2 0 0\n0 0 1 2 4 0\nSample Output\n19\nExplanation\ncontains the following hourglasses:\nThe hourglass with the maximum sum () is:\n2 4 4\n  2\n1 2 4",
        "92": "Declare a 2-dimensional array, , of empty arrays. All arrays are zero indexed.\nDeclare an integer, , and initialize it to .\nThere are types of queries, given as an array of strings for you to parse:\nQuery: 1 x y\nLet .\nAppend the integer to .\nQuery: 2 x y\nLet .\nAssign the value to .\nStore the new value of to an answers array.\nNote: is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. is the modulo operator.\nFinally, size(arr[idx]) is the number of elements in arr[idx]\nFunction Description\nComplete the dynamicArray function below.\ndynamicArray has the following parameters:\n- int n: the number of empty arrays to initialize in\n- string queries[q]: query strings that contain 3 space-separated integers\nReturns\nint[]: the results of each type 2 query in the order they are presented\nInput Format\nThe first line contains two space-separated integers, , the size of to create, and , the number of queries, respectively.\nEach of the subsequent lines contains a query string, .\nConstraints\nIt is guaranteed that query type will never query an empty array or index.\nSample Input\n2 5\n1 0 5\n1 1 7\n1 0 3\n2 1 0\n2 1 1\nSample Output\n7\n3\nExplanation\nInitial Values:\n\n\n= [ ]\n= [ ]\nQuery 0: Append to .\n\n= [5]\n= [ ]\nQuery 1: Append to .\n= [5]\n= [7]\nQuery 2: Append to .\n\n= [5, 3]\n= [7]\nQuery 3: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n7\nQuery 4: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n3",
        "93": "A left rotation operation on an array of size shifts each of the array's elements unit to the left. Given an integer, , rotate the array that many steps left and return the result.\nExample\n\nAfter rotations, .\nFunction Description\nComplete the rotateLeft function in the editor below.\nrotateLeft has the following parameters:\nint d: the amount to rotate by\nint arr[n]: the array to rotate\nReturns\nint[n]: the rotated array\nInput Format\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains space-separated integers that describe .\nConstraints\nSample Input\n5 4\n1 2 3 4 5\nSample Output\n5 1 2 3 4\nExplanation\nTo perform left rotations, the array undergoes the following sequence of changes:",
        "94": "There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.\nExample\n\nThere are instances of '', of '' and of ''. For each query, add an element to the return array, .\nFunction Description\nComplete the function matchingStrings in the editor below. The function must return an array of integers representing the frequency of occurrence of each query string in stringList.\nmatchingStrings has the following parameters:\nstring stringList[n] - an array of strings to search\nstring queries[q] - an array of query strings\nReturns\nint[q]: an array of results for each query\nInput Format\nThe first line contains and integer , the size of .\nEach of the next lines contains a string .\nThe next line contains , the size of .\nEach of the next lines contains a string .\nConstraints\n\n\n.",
        "95": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\nExample\n\nQueries are interpreted as follows:\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\nAdd the values of between the indices and inclusive:\nindex->  1 2 3  4  5 6 7 8 9 10\n [0,0,0, 0, 0,0,0,0,0, 0]\n [3,3,3, 3, 3,0,0,0,0, 0]\n [3,3,3,10,10,7,7,7,0, 0]\n [3,3,3,10,10,8,8,8,1, 0]\nThe largest value is after all operations are performed.\nFunction Description\nComplete the function arrayManipulation in the editor below.\narrayManipulation has the following parameters:\nint n - the number of elements in the array\nint queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.\nReturns\nint - the maximum value in the resultant array\nInput Format\nThe first line contains two space-separated integers and , the size of the array and the number of operations.\nEach of the next lines contains three space-separated integers , and , the left index, right index and summand.\nConstraints\nSample Input\n5 3\n1 2 100\n2 5 100\n3 4 100\nSample Output\n200\nExplanation\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\nThe maximum value is .",
        "96": "This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.\nThis is an to practice traversing a linked list. Given a pointer to the head node of a linked list, print each node's element, one per line. If the head pointer is null (indicating the list is empty), there is nothing to print.\nFunction Description\nComplete the printLinkedList function in the editor below.\nprintLinkedList has the following parameter(s):\nSinglyLinkedListNode head: a reference to the head of the list\nPrint\nFor each node, print its value on a new line (console.log in Javascript).\nInput Format\nThe first line of input contains , the number of elements in the linked list.\nThe next lines contain one element each, the values for each node.\nNote: Do not read any input from stdin\/console. Complete the printLinkedList function in the editor below.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n16\n13\nSample Output\n16\n13\nExplanation\nThere are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each on a new line.",
        "97": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nYou are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.\nFunction Description\nComplete the insertNodeAtTail function in the editor below.\ninsertNodeAtTail has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nint data: the data value for the node to insert\nReturns\nSinglyLinkedListNode pointer: reference to the head of the modified linked list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each, the value that needs to be inserted at tail.\nConstraints\nSample Input\nSTDIN Function ----- -------- 5 size of linked list n = 5 141 linked list data values 141..474 302 164 530 474\nSample Output\n141\n302\n164\n530\n474\nExplanation\nFirst the linked list is NULL. After inserting 141, the list is 141 -> NULL.\nAfter inserting 302, the list is 141 -> 302 -> NULL.\nAfter inserting 164, the list is 141 -> 302 -> 164 -> NULL.\nAfter inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.",
        "98": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a linked list, insert a new node before the head. The value in the new node should point to and the value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\nFunction Description\nComplete the function insertNodeAtHead in the editor below.\ninsertNodeAtHead has the following parameter(s):\nSinglyLinkedListNode llist: a reference to the head of a list\ndata: the value to insert in the field of the new node\nInput Format\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next lines contain an integer each, the elements to be inserted, one per function call.\nConstraints\nSample Input\n5\n383\n484\n392\n975\n321\nSample Output\n321\n975\n392\n484\n383\nExplanation\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "99": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node with the given integer as its attribute, insert this node at the desired position and return the head node.\nA position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.\nExample\nrefers to the first node in the list\n\nInsert a node at position with . The new list is\nFunction Description Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.\ninsertNodeAtPosition has the following parameters:\nhead: a SinglyLinkedListNode pointer to the head of the list\ndata: an integer value to insert as data in your new node\nposition: an integer position to insert the new node, zero based indexing\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer SinglyLinkedListNode[i].data.\nThe next line contains an integer , the data of the node that is to be inserted.\nThe last line contains an integer .\nConstraints\n, where is the element of the linked list.\n.\nSample Input\n3\n16\n13\n7\n1\n2\nSample Output\n16 13 1 7\nExplanation\nThe initial linked list is . Insert at the position which currently has in it. The updated linked list is .",
        "100": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nDelete the node at a given position in a linked list and return a reference to the head node. The head is at position 0. The list may be empty after you delete the node. In that case, return a null value.\nExample\n\nAfter removing the node at position , .\nFunction Description\nComplete the deleteNode function in the editor below.\ndeleteNode has the following parameters:\n- SinglyLinkedListNode pointer llist: a reference to the head node in the list\n- int position: the position of the node to remove\nReturns\n- SinglyLinkedListNode pointer: a reference to the head of the modified list\nInput Format\nThe first line of input contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the node data values in order.\nThe last line contains an integer, , the position of the node to delete.\nConstraints\n, where is the element of the linked list.\nSample Input\n8\n20\n6\n2\n19\n7\n4\n15\n9\n3\nSample Output\n20 6 2 7 4 15 9\nExplanation\nThe original list is . After deleting the node at position , the list is .",
        "101": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a singly-linked list, print each value from the reversed list. If the given list is empty, do not print anything.\nExample\nrefers to the linked list with values\nPrint the following:\n3\n2\n1\nFunction Description\nComplete the reversePrint function in the editor below.\nreversePrint has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nPrints\nThe values of each node in the reversed list.\nInput Format\nThe first line of input contains , the number of test cases.\nThe input of each test case is as follows:\nThe first line contains an integer , the number of elements in the list.\nEach of the next n lines contains a data element for a list node.\nConstraints\n, where is the element in the list.\nSample Input\n3\n5\n16\n12\n4\n2\n5\n3\n7\n3\n9\n5\n5\n1\n18\n3\n13\nSample Output\n5\n2\n4\n12\n16\n9\n3\n7\n13\n3\n18\n1\n5\nExplanation\nThere are three test cases. There are no blank lines between test case output.\nThe first linked list has elements: . Printing this in reverse order produces:\n5\n2\n4\n12\n16\nThe second linked list has elements: . Printing this in reverse order produces:\n9\n3\n7\nThe third linked list has elements: . Printing this in reverse order produces:\n13\n3\n18\n1\n5",
        "102": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\nExample\nreferences the list\nManipulate the pointers of each node in place and return , now referencing the head of the list .\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the values of the elements in the linked list.\nConstraints\n, where is the element in the list.\nSample Input\n1\n5\n1\n2\n3\n4\n5\nSample Output\n5 4 3 2 1 \nExplanation\nThe initial linked list is: .\nThe reversed linked list is: .",
        "103": "This challenge is part of a tutorial track by MyCodeSchool\nYou\u2019re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. If all data attributes are equal and the lists are the same length, return . Otherwise, return .\nExample\n\nThe two lists have equal data attributes for the first nodes. is longer, though, so the lists are not equal. Return .\nFunction Description\nComplete the compare_lists function in the editor below.\ncompare_lists has the following parameters:\nSinglyLinkedListNode llist1: a reference to the head of a list\nSinglyLinkedListNode llist2: a reference to the head of a list\nReturns\nint: return 1 if the lists are equal, or 0 otherwise\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test cases has the following format:\nThe first line contains an integer , the number of nodes in the first linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nThe next line contains an integer , the number of nodes in the second linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nConstraints\nOutput Format\nCompare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout\/console.\nThe output is handled by the code in the editor and it is as follows:\nFor each test case, in a new line, print if the two lists are equal, else print .\nSample Input\n2\n2\n1\n2\n1\n1\n2\n1\n2\n2\n1\n2\nSample Output\n0\n1\nExplanation\nThere are test cases, each with a pair of linked lists.\nIn the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL\nIn the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL",
        "104": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. Either head pointer may be null meaning that the corresponding list is empty.\nExample\nrefers to\nrefers to\nThe new list is\nFunction Description\nComplete the mergeLists function in the editor below.\nmergeLists has the following parameters:\nSinglyLinkedListNode pointer headA: a reference to the head of a list\nSinglyLinkedListNode pointer headB: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the merged list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the length of the first linked list.\nThe next lines contain an integer each, the elements of the linked list.\nThe next line contains an integer , the length of the second linked list.\nThe next lines contain an integer each, the elements of the second linked list.\nConstraints\n, where is the element of the list.\nSample Input\n1\n3\n1\n2\n3\n2\n3\n4\nSample Output\n1 2 3 3 4 \nExplanation\nThe first linked list is:\nThe second linked list is:\nHence, the merged linked list is:",
        "105": "This challenge is part of a tutorial track by MyCodeSchool\nGiven a pointer to the head of a linked list and a specific position, determine the data value at that position. Count backwards from the tail node. The tail is at postion 0, its parent is at 1 and so on.\nExample\nrefers to\nEach of the data values matches its distance from the tail. The value is at the desired position.\nFunction Description\nComplete the getNode function in the editor below.\ngetNode has the following parameters:\nSinglyLinkedListNode pointer head: refers to the head of the list\nint positionFromTail: the item to retrieve\nReturns\nint: the value at the desired position\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contains an integer, the data value for an element of the linked list.\nThe last line contains an integer , the position from the tail to retrieve the value of.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n1\n1\n0\n3\n3\n2\n1\n2\nSample Output\n1\n3\nExplanation\nIn the first case, there is one element in linked list with a value of 1. The last (only) element contains 1.\nIn the second case, the list is . The element with position of 2 from tail contains 3.",
        "106": "This challenge is part of a tutorial track by MyCodeSchool\nYou are given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete nodes and return a sorted list with each distinct value in the original list. The given head pointer may be null indicating that the list is empty.\nExample\nrefers to the first node in the list .\nRemove 1 of the data values and return pointing to the revised list .\nFunction Description\nComplete the removeDuplicates function in the editor below.\nremoveDuplicates has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the value for each of the elements of the linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n5       n = 5\n1       data values = 1, 2, 2, 3, 4\n2\n2\n3\n4\nSample Output\n1 2 3 4 \nExplanation\nThe initial linked list is: .\nThe final linked list is: .",
        "107": "A linked list is said to contain a cycle if any node is visited more than once while traversing the list. Given a pointer to the head of a linked list, determine if it contains a cycle. If it does, return . Otherwise, return .\nExample\nrefers to the list of nodes\nThe numbers shown are the node numbers, not their data values. There is no cycle in this list so return .\nrefers to the list of nodes\nThere is a cycle where node 3 points back to node 1, so return .\nFunction Description\nComplete the has_cycle function in the editor below.\nIt has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nint: if there is a cycle or if there is not\nNote: If the list is empty, will be null.\nInput Format\nThe code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity. Expand the section for the main function and review the code if you would like to figure out how to create a custom case.\nConstraints\nSample Input\nReferences to each of the following linked lists are passed as arguments to your function:\nSample Output\n0\n1\nExplanation\nThe first list has no cycle, so return .\nThe second list has a cycle, so return .",
        "108": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's value.\nNote: After the merge point, both lists will share the same node pointers.\nExample\nIn the diagram below, the two lists converge at Node x:\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     \/\n     [List #2] p--->q\nFunction Description\nComplete the findMergeNode function in the editor below.\nfindMergeNode has the following parameters:\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\nReturns\nint: the value of the node where the lists merge\nInput Format\nDo not read any input from stdin\/console.\nThe first line contains an integer , the number of test cases.\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer, that is the number of nodes in the first list.\nEach of the following lines contains a value for a node. The next line contains an integer, that is the number of nodes in the second list.\nEach of the following lines contains a value for a node.\nConstraints\nThe lists will merge.\n.\n.\nSample Input\nThe diagrams below are graphical representations of the lists that input nodes and are connected to.\nTest Case 0\n 1\n  \\\n   2--->3--->NULL\n  \/\n 1\nTest Case 1\n1--->2\n      \\\n       3--->Null\n      \/\n     1\nSample Output\n2\n3\nExplanation\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "109": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value and insert it at the proper location to maintain the sort.\nExample\nrefers to the list\nReturn a reference to the new list: .\nFunction Description\nComplete the sortedInsert function in the editor below.\nsortedInsert has two parameters:\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\nint data: An integer denoting the value of the field for the DoublyLinkedListNode you must insert into the list.\nReturns\nDoublyLinkedListNode pointer: a reference to the head of the list\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test case is in the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\nSample Output\n1 3 4 5 10\nExplanation\nThe initial doubly linked list is: .\nThe doubly linked list after insertion is:",
        "110": "This challenge is part of a tutorial track by MyCodeSchool\nGiven the pointer to the head node of a doubly linked list, reverse the order of the nodes in place. That is, change the next and prev pointers of the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.\nNote: The head node might be NULL to indicate that the list is empty.\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter(s):\nDoublyLinkedListNode head: a reference to the head of a DoublyLinkedList\nReturns\n- DoublyLinkedListNode: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case is of the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each denoting an element of the linked list.\nConstraints\nOutput Format\nReturn a reference to the head of your reversed list. The provided code will print the reverse array as a one line of space-separated integers for each test case.\nSample Input\n1\n4\n1\n2\n3\n4\nSample Output\n4 3 2 1 \nExplanation\nThe initial doubly linked list is:\nThe reversed doubly linked list is:",
        "111": "Complete the function in the editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the preOrder function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's preorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 4 6 \nExplanation\nThe preorder traversal of the binary tree is printed.",
        "112": "Complete the function in the editor below. It received parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's postorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4\nSample Output\n4 3 6 5 2 1 \nExplanation\nThe postorder traversal is shown.",
        "113": "In this challenge, you are required to implement inorder traversal of a tree.\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.\nInput Format\nOur hidden tester code passes the root node of a binary tree to your $inOrder* function.\nConstraints\nOutput Format\nPrint the tree's inorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 3 4 5 6 \nExplanation\nThe tree's inorder traversal results in as the required result.",
        "114": "The height of a binary tree is the number of edges between the tree's root and its furthest leaf. For example, the following binary tree is of height :\n\nFunction Description\nComplete the getHeight or height function in the editor. It must return the height of a binary tree as an integer.\ngetHeight or height has the following parameter(s):\nroot: a reference to the root of a binary tree.\nNote -The Height of binary tree with single node is taken as zero.\nInput Format\nThe first line contains an integer , the number of nodes in the tree.\nNext line contains space separated integer where th integer denotes node[i].data.\nNote: Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function. In a binary search tree, all nodes on the left branch of a node are less than the node value. All values on the right branch are greater than the node value.\nConstraints\n\nOutput Format\nYour function should return a single integer denoting the height of the binary tree.\nSample Input\nSample Output\n3\nExplanation\nThe longest root-to-leaf path is shown below:\nThere are nodes in this path that are connected by edges, meaning our binary tree's .",
        "115": "Given a pointer to the root of a binary tree, print the top view of the binary tree.\nThe tree as seen from the top the nodes, is called the top view of the tree.\nFor example :\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nTop View :\nComplete the function and print the resulting values on a single line separated by space.\nInput Format\nYou are given a function,\nvoid topView(node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values on a single line separated by space.\nSample Input\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nSample Output\n1 2 5 6\nExplanation\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nFrom the top, only nodes are visible.",
        "116": "Given a pointer to the root of a binary tree, you need to print the level order traversal of this tree. In level-order traversal, nodes are visited level by level from left to right. Complete the function and print the values in a single line separated by a space.\nFor example:\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nFor the above tree, the level order traversal is .\nInput Format\nYou are given a function,\nvoid levelOrder(Node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values in a single line separated by a space.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 6 4\nExplanation\nWe need to print the nodes level by level. We process each level from left to right.\nLevel Order Traversal: .",
        "117": "You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function.\nInput Format\nYou are given a function,\nNode * insert (Node * root ,int data) {\n\n}\nConstraints\nNo. of nodes in the tree 500\nOutput Format\nReturn the root of the binary search tree after inserting the value into the tree.\nSample Input\n        4\n       \/ \\\n      2   7\n     \/ \\\n    1   3\nThe value to be inserted is 6.\nSample Output\n         4\n       \/   \\\n      2     7\n     \/ \\   \/\n    1   3 6",
        "118": "Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit. If they are on the left side of the tree, they will be a 0 (zero). If on the right, they'll be a 1 (one). Only the leaves will contain a letter and its frequency count. All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.\nFor instance, consider the string ABRACADABRA. There are a total of characters in the string. This number should match the count in the ultimately determined root of the tree. Our frequencies are and . The two smallest frequencies are for and , both equal to , so we'll create a tree with them. The root node will contain the sum of the counts of its descendants, in this case . The left node will be the first character encountered, , and the right will contain . Next we have items with a character count of : the tree we just created, the character and the character . The tree came first, so it will go on the left of our new root node. will go on the right. Repeat until the tree is complete, then fill in the 's and 's for the edges. The finished graph looks like:\nInput characters are only present in the leaves. Internal nodes have a character value of \u03d5 (NULL). We can determine that our values for characters are:\nA - 0\nB - 111\nC - 1100\nD - 1101\nR - 10\nOur Huffman encoded string is:\nA B    R  A C     A D     A B    R  A\n0 111 10 0 1100 0 1101 0 111 10 0\nor\n01111001100011010111100\nTo avoid ambiguity, Huffman encoding is a prefix free encoding technique. No codeword appears as a prefix of any other codeword.\nTo decode the encoded string, follow the zeros and ones to a leaf and return the character there.\nYou are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.\nFunction Description\nComplete the function decode_huff in the editor below. It must return the decoded string.\ndecode_huff has the following parameters:\nroot: a reference to the root node of the Huffman tree\ns: a Huffman encoded string\nInput Format\nThere is one line of input containing the plain string, . Background code creates the Huffman tree then passes the head node and the encoded string to the function.\nConstraints\nOutput Format\nOutput the decoded string on a single line.\nSample Input\ns=\"1001011\"\nSample Output\nABACA\nExplanation\nS=\"1001011\"\nProcessing the string from left to right.\nS[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[1]='0' : we move to the left child. \nS[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.\nWe move back to the root.\n\nS[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[4]='0' : we move to the left child. \nS[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.\nWe move back to the root.\n\n S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nDecoded String = \"ABACA\"",
        "119": "You are given pointer to the root of the binary search tree and two values and . You need to return the lowest common ancestor (LCA) of and in the binary search tree.\n\nIn the diagram above, the lowest common ancestor of the nodes and is the node . Node is the lowest node which has nodes and as descendants.\nFunction Description\nComplete the function lca in the editor below. It should return a pointer to the lowest common ancestor node of the two values given.\nlca has the following parameters:\n- root: a pointer to the root node of a binary search tree\n- v1: a node.data value\n- v2: a node.data value\nInput Format\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers representing values.\nThe third line contains two space-separated integers, and .\nTo use the test data, you will have to create the binary search tree yourself. Here on the platform, the tree will be created for you.\nConstraints\n\n\n\nThe tree will contain nodes with data equal to and .\nOutput Format\nReturn the a pointer to the node that is the lowest common ancestor of and .\nSample Input\n6\n4 2 3 1 7 6\n1 7\nand .\nSample Output\n[reference to node 4]\nExplanation\nLCA of and is , the root in this case.\nReturn a pointer to the node.",
        "120": "A binary tree is a tree which is characterized by one of the following properties:\nIt can be empty (null).\nIt contains a root node only.\nIt contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees.\nIn-order traversal is performed as\nTraverse the left subtree.\nVisit root.\nTraverse the right subtree.\nFor this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf. When you reach a leaf, back up to its parent, check for a right child and visit it if there is one. If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner. Keep doing this until you have traversed the entire tree. You will only store the values of a node as you visit when one of the following is true:\nit is the first node visited, the first time visited\nit is a leaf, should only be visited once\nall of its subtrees have been explored, should only be visited once while this is true\nit is the root of the tree, the first time visited\nSwapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L.\nFor example, in the following tree, we swap children of node 1.\n                                Depth\n    1               1            [1]\n   \/ \\             \/ \\\n  2   3     ->    3   2          [2]\n   \\   \\           \\   \\\n    4   5           5   4        [3]\nIn-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4.\nSwap operation:\nWe define depth of a node as follows:\nThe root node is at depth 1.\nIf the depth of the parent node is d, then the depth of current node will be d+1.\nGiven a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h \u2208 [k, 2k, 3k,...]. In other words, if h is a multiple of k, swap the left and right subtrees of that level.\nYou are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree.\nFunction Description\nComplete the swapNodes function in the editor below. It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation.\nswapNodes has the following parameter(s):\n- indexes: an array of integers representing index values of each , beginning with , the first element, as the root.\n- queries: an array of integers, each representing a value.\nInput Format\nThe first line contains n, number of nodes in the tree.\nEach of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.\nNote: -1 is used to represent a null node.\nThe next line contains an integer, t, the size of .\nEach of the next t lines contains an integer , each being a value .\nOutput Format\nFor each k, perform the swap operation and store the indices of your in-order traversal to your result array. After all swap operations have been performed, return your result array for printing.\nConstraints\nEither or\nEither or\nThe index of a non-null child will always be greater than that of its parent.\nSample Input 0\n3\n2 3\n-1 -1\n-1 -1\n2\n1\n1\nSample Output 0\n3 1 2\n2 1 3\nExplanation 0\nAs nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.\n    1   [s]       1    [s]       1   \n   \/ \\      ->   \/ \\        ->  \/ \\  \n  2   3 [s]     3   2  [s]     2   3\nNote: [s] indicates that a swap operation is done at this depth.\nSample Input 1\n5\n2 3\n-1 4\n-1 5\n-1 -1\n-1 -1\n1\n2\nSample Output 1\n4 2 1 5 3\nExplanation 1\nSwapping child nodes of node 2 and 3 we get\n    1                  1  \n   \/ \\                \/ \\ \n  2   3   [s]  ->    2   3\n   \\   \\            \/   \/ \n    4   5          4   5  \nSample Input 2\n11\n2 3\n4 -1\n5 -1\n6 -1\n7 8\n-1 9\n-1 -1\n10 11\n-1 -1\n-1 -1\n-1 -1\n2\n2\n4\nSample Output 2\n2 9 6 4 1 3 7 5 11 8 10\n2 6 9 4 1 3 7 5 10 8 11\nExplanation 2\nHere we perform swap operations at the nodes whose depth is either 2 or 4 for and then at nodes whose depth is 4 for .\n         1                     1                          1             \n        \/ \\                   \/ \\                        \/ \\            \n       \/   \\                 \/   \\                      \/   \\           \n      2     3    [s]        2     3                    2     3          \n     \/      \/                \\     \\                    \\     \\         \n    \/      \/                  \\     \\                    \\     \\        \n   4      5          ->        4     5          ->        4     5       \n  \/      \/ \\                  \/     \/ \\                  \/     \/ \\      \n \/      \/   \\                \/     \/   \\                \/     \/   \\     \n6      7     8   [s]        6     7     8   [s]        6     7     8\n \\          \/ \\            \/           \/ \\              \\         \/ \\   \n  \\        \/   \\          \/           \/   \\              \\       \/   \\  \n   9      10   11        9           11   10              9     10   11 ",
        "121": "Kitty has a tree, , consisting of nodes where each node is uniquely labeled from to . Her friend Alex gave her sets, where each set contains distinct nodes. Kitty needs to calculate the following expression on each set:\nwhere:\ndenotes an unordered pair of nodes belonging to the set.\ndenotes the number of edges on the unique (shortest) path between nodes and .\nGiven and sets of distinct nodes, calculate the expression for each set. For each set of nodes, print the value of the expression modulo on a new line.\nExample\n\nThe graph looks like this:\n\nThere are three pairs that can be created from the query set: . The distance from to is , from to is , and from to is .\nNow do the summation:\nInput Format\nThe first line contains two space-separated integers, the respective values of (the number of nodes in tree ) and (the number of nodes in the query set).\nEach of the subsequent lines contains two space-separated integers, and , that describe an undirected edge between nodes and .\nThe subsequent lines define each set over two lines in the following format:\nThe first line contains an integer, , the size of the set.\nThe second line contains space-separated integers, the set's elements.\nConstraints\nThe sum of over all does not exceed .\nAll elements in each set are distinct.\nSubtasks\nfor of the maximum score.\nfor of the maximum score.\nfor of the maximum score.\nOutput Format\nPrint lines of output where each line contains the expression for the query, modulo .\nSample Input 0\n7 3\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n2\n2 4\n1\n5\n3\n2 4 5\nSample Output 0\n16\n0\n106\nExplanation 0\nTree looks like this:\nWe perform the following calculations for sets:\nSet : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:\nSet : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print on a new line.\nSet : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:",
        "122": "For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements:\nThe value of every node in a node's left subtree is less than the data value of that node.\nThe value of every node in a node's right subtree is greater than the data value of that node.\nGiven the root node of a binary tree, can you determine if it's also a binary search tree?\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.\nInput Format\nYou are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument.\nConstraints\nOutput Format\nYou are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line.\nSample Input\nSample Output\nNo",
        "123": "The square-ten tree decomposition of an array is defined as follows:\nThe lowest () level of the square-ten tree consists of single array elements in their natural order.\nThe level (starting from ) of the square-ten tree consists of subsequent array subsegments of length in their natural order. Thus, the level contains subsegments of length , the level contains subsegments of length , the level contains subsegments of length , etc.\nIn other words, every level (for every ) of square-ten tree consists of array subsegments indexed as:\nLevel consists of array subsegments indexed as .\nThe image below depicts the bottom-left corner (i.e., the first array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:\nTask\nGiven the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence such as for every , , , where every belongs to any of the square-ten tree levels and is minimal amongst all such variants.\nInput Format\nThe first line contains a single integer denoting .\nThe second line contains a single integer denoting .\nConstraints\nThe numbers in input do not contain leading zeroes.\nOutput Format\nAs soon as array indices are too large, you should find a sequence of square-ten tree level numbers, , meaning that subsegment belongs to the level of the square-ten tree.\nPrint this sequence in the following compressed format:\nOn the first line, print the value of (i.e., the compressed sequence block count).\nFor each of the subsequent lines, print space-separated integers, and (, ), meaning that the number appears consequently times in sequence . Blocks should be listed in the order they appear in the sequence. In other words, should be equal to , should be equal to , etc.\nThus must be true and must be true for every . All numbers should be printed without leading zeroes.\nSample Input 0\n1\n10\nSample Output 0\n1\n1 1\nExplanation 0\nSegment belongs to level of the square-ten tree.",
        "124": "Greg has a tree of nodes containing integer data. He wants to insert a node with some non-zero integer value somewhere into the tree. His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount. This is called a balanced forest. Being frugal, the data value he inserts should be minimal. Determine the minimal amount that a new node can have to allow creation of a balanced forest. If it's not possible to create a balanced forest, return -1.\nFor example, you are given node values and . It is the following tree:\nThe blue node is root, the first number in a node is node number and the second is its value. Cuts can be made between nodes and and nodes and to have three trees with sums , and . Adding a new node of to the third tree completes the solution.\nFunction Description\nComplete the balancedForest function in the editor below. It must return an integer representing the minimum value of that can be added to allow creation of a balanced forest, or if it is not possible.\nbalancedForest has the following parameter(s):\nc: an array of integers, the data values for each node\nedges: an array of 2 element arrays, the node pairs per edge\nInput Format\nThe first line contains a single integer, , the number of queries.\nEach of the following sets of lines is as follows:\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers describing the respective values of , where each denotes the value at node .\nEach of the following lines contains two space-separated integers, and , describing edge connecting nodes and .\nConstraints\nEach query forms a valid undirected tree.\nSubtasks\nFor of the maximum score:\nFor of the maximum score:\nOutput Format\nFor each query, return the minimum value of the integer . If no such value exists, return instead.\nSample Input\n2\n5\n1 2 2 1 1\n1 2\n1 3\n3 5\n1 4\n3\n1 3 5\n1 3\n1 2\nSample Output\n2\n-1\nExplanation\nWe perform the following two queries:\nThe tree initially looks like this:\n\nGreg can add a new node with and create a new edge connecting nodes and . Then he cuts the edge connecting nodes and and the edge connecting nodes and . We now have a three-tree balanced forest where each tree has a sum of .\nIn the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .",
        "125": "Jenny loves experimenting with trees. Her favorite tree has nodes connected by edges, and each edge is unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius from this tree by performing the following two steps:\nChoose a node, , from the tree.\nCut a subtree consisting of all nodes which are not further than units from node .\nFor example, the blue nodes in the diagram below depict a subtree centered at that has radius :\nGiven , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not isomorphic.\nInput Format\nThe first line contains two space-separated integers denoting the respective values of and .\nEach of the next subsequent lines contains two space-separated integers, and , describing a bidirectional edge in Jenny's tree having length .\nConstraints\nSubtasks\nFor of the max score:\nOutput Format\nPrint the total number of different possible subtrees.\nSample Input 0\n7 1\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\nSample Output 0\n3\nExplanation 0\nIn the diagram below, blue nodes denote the possible subtrees:\nThe last subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print as our answer.\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\nSample Output 1\n4\nExplanation 1\nIn the diagram below, blue nodes denote the possible subtrees:\nHere, we have four possible different subtrees.",
        "126": "We consider metric space to be a pair, , where is a set and such that the following conditions hold:\nwhere is the distance between points and .\nLet's define the product of two metric spaces, , to be such that:\n, where , .\nSo, it follows logically that is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: .\nFor example, , where is a metric space. , where .\nIn this challenge, we need a tree-space. You're given a tree, , where is the set of vertices and is the set of edges. Let the function be the distance between two vertices in tree (i.e., is the number of edges on the path between vertices and ). Note that is a metric space.\nYou are given a tree, , with vertices, as well as points in . Find and print the distance between the two furthest points in this metric space!\nInput Format\nThe first line contains two space-separated positive integers describing the respective values of (the number of vertices in ) and (the number of given points).\nEach line of the subsequent lines contains two space-separated integers, and , describing edge in .\nEach line of the subsequent lines contains two space-separated integers describing the respective values of and for point .\nConstraints\nScoring\nThis challenge uses binary scoring, so you must pass all test cases to earn a positive score.\nOutput Format\nPrint a single non-negative integer denoting the maximum distance between two of the given points in metric space .\nSample Input 0\n2 2\n1 2\n1 2\n2 1\nSample Output 0\n2\nExplanation 0\nThe distance between points and is .\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n3 6\n4 5\n5 5\nSample Output 1\n3\nExplanation 1\nThe best points are and , which gives us a distance of .",
        "127": "Consider an array of integers, . Find and print the total number of pairs such that where .\nInput Format\nThe first line contains an integer, , denoting the number of elements in the array.\nThe second line consists of space-separated integers describing the respective values of .\nConstraints\nScoring\nfor of the test cases.\nfor of the test cases.\nfor of the test cases.\nOutput Format\nPrint a long integer denoting the total number pairs satisfying where .\nSample Input\n5  \n1 1 2 4 2\nSample Output\n8\nExplanation\nThere are eight pairs of indices satisfying the given criteria: , , , , , , , and . Thus, we print as our answer.",
        "128": "An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.\nWe define balance factor for each node as :\nbalanceFactor = height(left subtree) - height(right subtree)\nThe balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than \u22121 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.\n(https:\/\/en.wikipedia.org\/wiki\/AVL_tree)\nYou are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.\nInput Format\nYou are given a function,\nnode *insert(node * root,int new_val)\n{\n\n\n}\n'node' is defined as :\nstruct node\n{\nint val;            \/\/value\nstruct node* left;  \/\/left child\nstruct node* right; \/\/right child\nint ht;             \/\/height of the node\n} node;\nYou only need to complete the function.\nNote: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.\n\nOutput Format\nInsert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced.\nSample Input\n    3\n  \/  \\\n 2    4\n       \\\n        5\nThe value to be inserted is 6.\nSample Output\n    3\n  \/  \\\n 2    5\n     \/ \\\n    4   6\nExplanation\nAfter inserting 6 in the tree. the tree becomes:\n    3 (Balance Factor = -2)\n  \/  \\\n 2    4 (Balance Factor = -2)\n       \\\n        5 (Balance Factor = -1)\n         \\\n          6 (Balance Factor = 0)\nBalance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree.\nAfter performing the rotation, the tree becomes :\n                              3 (Balance Factor = -1)\n                            \/   \\\n      (Balance Factor = 0) 2     5 (Balance Factor = 0)\n                                \/ \\\n           (Balance Factor = 0)4   6 (Balance Factor = 0)",
        "129": "Given two numbers and . indicates the number of elements in the array and indicates number of queries. You need to perform two types of queries on the array .\nYou are given queries. Queries can be of two types, type 1 and type 2.\nType 1 queries are represented as 1 i j : Modify the given array by removing elements from to and adding them to the front.\nType 2 queries are represented as 2 i j : Modify the given array by removing elements from to and adding them to the back.\nYour task is to simply print of the resulting array after the execution of queries followed by the resulting array.\nNote While adding at back or front the order of elements is preserved.\nInput Format\nFirst line consists of two space-separated integers, and .\nSecond line contains integers, which represent the elements of the array.\nqueries follow. Each line contains a query of either type 1 or type 2 in the form\nConstraints\n\n\nOutput Format\nPrint the absolute value i.e. in the first line.\nPrint elements of the resulting array in the second line. Each element should be seperated by a single space.\nSample Input\n8 4\n1 2 3 4 5 6 7 8\n1 2 4\n2 3 5\n1 4 7\n2 1 4\nSample Output\n1\n2 3 6 5 7 8 4 1\nExplanation\nGiven array is .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nNow is i.e. and the array is",
        "130": "An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index, (where ), that can be referenced as or .\nReverse an array of integers.\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\nExample\nReturn .\nFunction Description\nComplete the function reverseArray in the editor below.\nreverseArray has the following parameter(s):\nint A[n]: the array to reverse\nReturns\nint[n]: the reversed array\nInput Format\nThe first line contains an integer, , the number of integers in .\nThe second line contains space-separated integers that make up .\nConstraints",
        "131": "Given a 2D Array, :\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\nAn hourglass in is a subset of values with indices falling in this pattern in 's graphical representation:\na b c\n  d\ne f g\nThere are hourglasses in . An hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. The array will always be .\nExample\n-9 -9 -9  1 1 1 \n 0 -9  0  4 3 2\n-9 -9 -9  1 2 3\n 0  0  8  6 6 0\n 0  0  0 -2 0 0\n 0  0  1  2 4 0\nThe hourglass sums are:\n-63, -34, -9, 12, \n-10,   0, 28, 23, \n-27, -11, -2, 10, \n  9,  17, 25, 18\nThe highest hourglass sum is from the hourglass beginning at row , column :\n0 4 3\n  1\n8 6 6\nNote: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.\nFunction Description\nComplete the function hourglassSum in the editor below.\nhourglassSum has the following parameter(s):\nint arr[6][6]: an array of integers\nReturns\nint: the maximum hourglass sum\nInput Format\nEach of the lines of inputs contains space-separated integers .\nConstraints\nOutput Format\nPrint the largest (maximum) hourglass sum found in .\nSample Input\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 2 4 4 0\n0 0 0 2 0 0\n0 0 1 2 4 0\nSample Output\n19\nExplanation\ncontains the following hourglasses:\nThe hourglass with the maximum sum () is:\n2 4 4\n  2\n1 2 4",
        "132": "Declare a 2-dimensional array, , of empty arrays. All arrays are zero indexed.\nDeclare an integer, , and initialize it to .\nThere are types of queries, given as an array of strings for you to parse:\nQuery: 1 x y\nLet .\nAppend the integer to .\nQuery: 2 x y\nLet .\nAssign the value to .\nStore the new value of to an answers array.\nNote: is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. is the modulo operator.\nFinally, size(arr[idx]) is the number of elements in arr[idx]\nFunction Description\nComplete the dynamicArray function below.\ndynamicArray has the following parameters:\n- int n: the number of empty arrays to initialize in\n- string queries[q]: query strings that contain 3 space-separated integers\nReturns\nint[]: the results of each type 2 query in the order they are presented\nInput Format\nThe first line contains two space-separated integers, , the size of to create, and , the number of queries, respectively.\nEach of the subsequent lines contains a query string, .\nConstraints\nIt is guaranteed that query type will never query an empty array or index.\nSample Input\n2 5\n1 0 5\n1 1 7\n1 0 3\n2 1 0\n2 1 1\nSample Output\n7\n3\nExplanation\nInitial Values:\n\n\n= [ ]\n= [ ]\nQuery 0: Append to .\n\n= [5]\n= [ ]\nQuery 1: Append to .\n= [5]\n= [7]\nQuery 2: Append to .\n\n= [5, 3]\n= [7]\nQuery 3: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n7\nQuery 4: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n3",
        "133": "A left rotation operation on an array of size shifts each of the array's elements unit to the left. Given an integer, , rotate the array that many steps left and return the result.\nExample\n\nAfter rotations, .\nFunction Description\nComplete the rotateLeft function in the editor below.\nrotateLeft has the following parameters:\nint d: the amount to rotate by\nint arr[n]: the array to rotate\nReturns\nint[n]: the rotated array\nInput Format\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains space-separated integers that describe .\nConstraints\nSample Input\n5 4\n1 2 3 4 5\nSample Output\n5 1 2 3 4\nExplanation\nTo perform left rotations, the array undergoes the following sequence of changes:",
        "134": "There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.\nExample\n\nThere are instances of '', of '' and of ''. For each query, add an element to the return array, .\nFunction Description\nComplete the function matchingStrings in the editor below. The function must return an array of integers representing the frequency of occurrence of each query string in stringList.\nmatchingStrings has the following parameters:\nstring stringList[n] - an array of strings to search\nstring queries[q] - an array of query strings\nReturns\nint[q]: an array of results for each query\nInput Format\nThe first line contains and integer , the size of .\nEach of the next lines contains a string .\nThe next line contains , the size of .\nEach of the next lines contains a string .\nConstraints\n\n\n.",
        "135": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\nExample\n\nQueries are interpreted as follows:\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\nAdd the values of between the indices and inclusive:\nindex->  1 2 3  4  5 6 7 8 9 10\n [0,0,0, 0, 0,0,0,0,0, 0]\n [3,3,3, 3, 3,0,0,0,0, 0]\n [3,3,3,10,10,7,7,7,0, 0]\n [3,3,3,10,10,8,8,8,1, 0]\nThe largest value is after all operations are performed.\nFunction Description\nComplete the function arrayManipulation in the editor below.\narrayManipulation has the following parameters:\nint n - the number of elements in the array\nint queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.\nReturns\nint - the maximum value in the resultant array\nInput Format\nThe first line contains two space-separated integers and , the size of the array and the number of operations.\nEach of the next lines contains three space-separated integers , and , the left index, right index and summand.\nConstraints\nSample Input\n5 3\n1 2 100\n2 5 100\n3 4 100\nSample Output\n200\nExplanation\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\nThe maximum value is .",
        "136": "This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.\nThis is an to practice traversing a linked list. Given a pointer to the head node of a linked list, print each node's element, one per line. If the head pointer is null (indicating the list is empty), there is nothing to print.\nFunction Description\nComplete the printLinkedList function in the editor below.\nprintLinkedList has the following parameter(s):\nSinglyLinkedListNode head: a reference to the head of the list\nPrint\nFor each node, print its value on a new line (console.log in Javascript).\nInput Format\nThe first line of input contains , the number of elements in the linked list.\nThe next lines contain one element each, the values for each node.\nNote: Do not read any input from stdin\/console. Complete the printLinkedList function in the editor below.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n16\n13\nSample Output\n16\n13\nExplanation\nThere are two elements in the linked list. They are represented as 16 -> 13 -> NULL. So, the printLinkedList function should print 16 and 13 each on a new line.",
        "137": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nYou are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.\nFunction Description\nComplete the insertNodeAtTail function in the editor below.\ninsertNodeAtTail has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nint data: the data value for the node to insert\nReturns\nSinglyLinkedListNode pointer: reference to the head of the modified linked list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each, the value that needs to be inserted at tail.\nConstraints\nSample Input\nSTDIN Function ----- -------- 5 size of linked list n = 5 141 linked list data values 141..474 302 164 530 474\nSample Output\n141\n302\n164\n530\n474\nExplanation\nFirst the linked list is NULL. After inserting 141, the list is 141 -> NULL.\nAfter inserting 302, the list is 141 -> 302 -> NULL.\nAfter inserting 164, the list is 141 -> 302 -> 164 -> NULL.\nAfter inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.",
        "138": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a linked list, insert a new node before the head. The value in the new node should point to and the value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\nFunction Description\nComplete the function insertNodeAtHead in the editor below.\ninsertNodeAtHead has the following parameter(s):\nSinglyLinkedListNode llist: a reference to the head of a list\ndata: the value to insert in the field of the new node\nInput Format\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next lines contain an integer each, the elements to be inserted, one per function call.\nConstraints\nSample Input\n5\n383\n484\n392\n975\n321\nSample Output\n321\n975\n392\n484\n383\nExplanation\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "139": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node with the given integer as its attribute, insert this node at the desired position and return the head node.\nA position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.\nExample\nrefers to the first node in the list\n\nInsert a node at position with . The new list is\nFunction Description Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.\ninsertNodeAtPosition has the following parameters:\nhead: a SinglyLinkedListNode pointer to the head of the list\ndata: an integer value to insert as data in your new node\nposition: an integer position to insert the new node, zero based indexing\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer SinglyLinkedListNode[i].data.\nThe next line contains an integer , the data of the node that is to be inserted.\nThe last line contains an integer .\nConstraints\n, where is the element of the linked list.\n.\nSample Input\n3\n16\n13\n7\n1\n2\nSample Output\n16 13 1 7\nExplanation\nThe initial linked list is . Insert at the position which currently has in it. The updated linked list is .",
        "140": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nDelete the node at a given position in a linked list and return a reference to the head node. The head is at position 0. The list may be empty after you delete the node. In that case, return a null value.\nExample\n\nAfter removing the node at position , .\nFunction Description\nComplete the deleteNode function in the editor below.\ndeleteNode has the following parameters:\n- SinglyLinkedListNode pointer llist: a reference to the head node in the list\n- int position: the position of the node to remove\nReturns\n- SinglyLinkedListNode pointer: a reference to the head of the modified list\nInput Format\nThe first line of input contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the node data values in order.\nThe last line contains an integer, , the position of the node to delete.\nConstraints\n, where is the element of the linked list.\nSample Input\n8\n20\n6\n2\n19\n7\n4\n15\n9\n3\nSample Output\n20 6 2 7 4 15 9\nExplanation\nThe original list is . After deleting the node at position , the list is .",
        "141": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a singly-linked list, print each value from the reversed list. If the given list is empty, do not print anything.\nExample\nrefers to the linked list with values\nPrint the following:\n3\n2\n1\nFunction Description\nComplete the reversePrint function in the editor below.\nreversePrint has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nPrints\nThe values of each node in the reversed list.\nInput Format\nThe first line of input contains , the number of test cases.\nThe input of each test case is as follows:\nThe first line contains an integer , the number of elements in the list.\nEach of the next n lines contains a data element for a list node.\nConstraints\n, where is the element in the list.\nSample Input\n3\n5\n16\n12\n4\n2\n5\n3\n7\n3\n9\n5\n5\n1\n18\n3\n13\nSample Output\n5\n2\n4\n12\n16\n9\n3\n7\n13\n3\n18\n1\n5\nExplanation\nThere are three test cases. There are no blank lines between test case output.\nThe first linked list has elements: . Printing this in reverse order produces:\n5\n2\n4\n12\n16\nThe second linked list has elements: . Printing this in reverse order produces:\n9\n3\n7\nThe third linked list has elements: . Printing this in reverse order produces:\n13\n3\n18\n1\n5",
        "142": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\nExample\nreferences the list\nManipulate the pointers of each node in place and return , now referencing the head of the list .\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the values of the elements in the linked list.\nConstraints\n, where is the element in the list.\nSample Input\n1\n5\n1\n2\n3\n4\n5\nSample Output\n5 4 3 2 1 \nExplanation\nThe initial linked list is: .\nThe reversed linked list is: .",
        "143": "This challenge is part of a tutorial track by MyCodeSchool\nYou\u2019re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. If all data attributes are equal and the lists are the same length, return . Otherwise, return .\nExample\n\nThe two lists have equal data attributes for the first nodes. is longer, though, so the lists are not equal. Return .\nFunction Description\nComplete the compare_lists function in the editor below.\ncompare_lists has the following parameters:\nSinglyLinkedListNode llist1: a reference to the head of a list\nSinglyLinkedListNode llist2: a reference to the head of a list\nReturns\nint: return 1 if the lists are equal, or 0 otherwise\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test cases has the following format:\nThe first line contains an integer , the number of nodes in the first linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nThe next line contains an integer , the number of nodes in the second linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nConstraints\nOutput Format\nCompare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout\/console.\nThe output is handled by the code in the editor and it is as follows:\nFor each test case, in a new line, print if the two lists are equal, else print .\nSample Input\n2\n2\n1\n2\n1\n1\n2\n1\n2\n2\n1\n2\nSample Output\n0\n1\nExplanation\nThere are test cases, each with a pair of linked lists.\nIn the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL\nIn the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL",
        "144": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. Either head pointer may be null meaning that the corresponding list is empty.\nExample\nrefers to\nrefers to\nThe new list is\nFunction Description\nComplete the mergeLists function in the editor below.\nmergeLists has the following parameters:\nSinglyLinkedListNode pointer headA: a reference to the head of a list\nSinglyLinkedListNode pointer headB: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the merged list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the length of the first linked list.\nThe next lines contain an integer each, the elements of the linked list.\nThe next line contains an integer , the length of the second linked list.\nThe next lines contain an integer each, the elements of the second linked list.\nConstraints\n, where is the element of the list.\nSample Input\n1\n3\n1\n2\n3\n2\n3\n4\nSample Output\n1 2 3 3 4 \nExplanation\nThe first linked list is:\nThe second linked list is:\nHence, the merged linked list is:",
        "145": "This challenge is part of a tutorial track by MyCodeSchool\nGiven a pointer to the head of a linked list and a specific position, determine the data value at that position. Count backwards from the tail node. The tail is at postion 0, its parent is at 1 and so on.\nExample\nrefers to\nEach of the data values matches its distance from the tail. The value is at the desired position.\nFunction Description\nComplete the getNode function in the editor below.\ngetNode has the following parameters:\nSinglyLinkedListNode pointer head: refers to the head of the list\nint positionFromTail: the item to retrieve\nReturns\nint: the value at the desired position\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contains an integer, the data value for an element of the linked list.\nThe last line contains an integer , the position from the tail to retrieve the value of.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n1\n1\n0\n3\n3\n2\n1\n2\nSample Output\n1\n3\nExplanation\nIn the first case, there is one element in linked list with a value of 1. The last (only) element contains 1.\nIn the second case, the list is . The element with position of 2 from tail contains 3.",
        "146": "This challenge is part of a tutorial track by MyCodeSchool\nYou are given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete nodes and return a sorted list with each distinct value in the original list. The given head pointer may be null indicating that the list is empty.\nExample\nrefers to the first node in the list .\nRemove 1 of the data values and return pointing to the revised list .\nFunction Description\nComplete the removeDuplicates function in the editor below.\nremoveDuplicates has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the value for each of the elements of the linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n5       n = 5\n1       data values = 1, 2, 2, 3, 4\n2\n2\n3\n4\nSample Output\n1 2 3 4 \nExplanation\nThe initial linked list is: .\nThe final linked list is: .",
        "147": "A linked list is said to contain a cycle if any node is visited more than once while traversing the list. Given a pointer to the head of a linked list, determine if it contains a cycle. If it does, return . Otherwise, return .\nExample\nrefers to the list of nodes\nThe numbers shown are the node numbers, not their data values. There is no cycle in this list so return .\nrefers to the list of nodes\nThere is a cycle where node 3 points back to node 1, so return .\nFunction Description\nComplete the has_cycle function in the editor below.\nIt has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nint: if there is a cycle or if there is not\nNote: If the list is empty, will be null.\nInput Format\nThe code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity. Expand the section for the main function and review the code if you would like to figure out how to create a custom case.\nConstraints\nSample Input\nReferences to each of the following linked lists are passed as arguments to your function:\nSample Output\n0\n1\nExplanation\nThe first list has no cycle, so return .\nThe second list has a cycle, so return .",
        "148": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's value.\nNote: After the merge point, both lists will share the same node pointers.\nExample\nIn the diagram below, the two lists converge at Node x:\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     \/\n     [List #2] p--->q\nFunction Description\nComplete the findMergeNode function in the editor below.\nfindMergeNode has the following parameters:\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\nReturns\nint: the value of the node where the lists merge\nInput Format\nDo not read any input from stdin\/console.\nThe first line contains an integer , the number of test cases.\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer, that is the number of nodes in the first list.\nEach of the following lines contains a value for a node. The next line contains an integer, that is the number of nodes in the second list.\nEach of the following lines contains a value for a node.\nConstraints\nThe lists will merge.\n.\n.\nSample Input\nThe diagrams below are graphical representations of the lists that input nodes and are connected to.\nTest Case 0\n 1\n  \\\n   2--->3--->NULL\n  \/\n 1\nTest Case 1\n1--->2\n      \\\n       3--->Null\n      \/\n     1\nSample Output\n2\n3\nExplanation\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "149": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value and insert it at the proper location to maintain the sort.\nExample\nrefers to the list\nReturn a reference to the new list: .\nFunction Description\nComplete the sortedInsert function in the editor below.\nsortedInsert has two parameters:\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\nint data: An integer denoting the value of the field for the DoublyLinkedListNode you must insert into the list.\nReturns\nDoublyLinkedListNode pointer: a reference to the head of the list\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test case is in the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\nSample Output\n1 3 4 5 10\nExplanation\nThe initial doubly linked list is: .\nThe doubly linked list after insertion is:",
        "150": "This challenge is part of a tutorial track by MyCodeSchool\nGiven the pointer to the head node of a doubly linked list, reverse the order of the nodes in place. That is, change the next and prev pointers of the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.\nNote: The head node might be NULL to indicate that the list is empty.\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter(s):\nDoublyLinkedListNode head: a reference to the head of a DoublyLinkedList\nReturns\n- DoublyLinkedListNode: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case is of the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each denoting an element of the linked list.\nConstraints\nOutput Format\nReturn a reference to the head of your reversed list. The provided code will print the reverse array as a one line of space-separated integers for each test case.\nSample Input\n1\n4\n1\n2\n3\n4\nSample Output\n4 3 2 1 \nExplanation\nThe initial doubly linked list is:\nThe reversed doubly linked list is:",
        "151": "Complete the function in the editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the preOrder function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's preorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 4 6 \nExplanation\nThe preorder traversal of the binary tree is printed.",
        "152": "Complete the function in the editor below. It received parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's postorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4\nSample Output\n4 3 6 5 2 1 \nExplanation\nThe postorder traversal is shown.",
        "153": "In this challenge, you are required to implement inorder traversal of a tree.\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.\nInput Format\nOur hidden tester code passes the root node of a binary tree to your $inOrder* function.\nConstraints\nOutput Format\nPrint the tree's inorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 3 4 5 6 \nExplanation\nThe tree's inorder traversal results in as the required result.",
        "154": "The height of a binary tree is the number of edges between the tree's root and its furthest leaf. For example, the following binary tree is of height :\n\nFunction Description\nComplete the getHeight or height function in the editor. It must return the height of a binary tree as an integer.\ngetHeight or height has the following parameter(s):\nroot: a reference to the root of a binary tree.\nNote -The Height of binary tree with single node is taken as zero.\nInput Format\nThe first line contains an integer , the number of nodes in the tree.\nNext line contains space separated integer where th integer denotes node[i].data.\nNote: Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function. In a binary search tree, all nodes on the left branch of a node are less than the node value. All values on the right branch are greater than the node value.\nConstraints\n\nOutput Format\nYour function should return a single integer denoting the height of the binary tree.\nSample Input\nSample Output\n3\nExplanation\nThe longest root-to-leaf path is shown below:\nThere are nodes in this path that are connected by edges, meaning our binary tree's .",
        "155": "Given a pointer to the root of a binary tree, print the top view of the binary tree.\nThe tree as seen from the top the nodes, is called the top view of the tree.\nFor example :\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nTop View :\nComplete the function and print the resulting values on a single line separated by space.\nInput Format\nYou are given a function,\nvoid topView(node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values on a single line separated by space.\nSample Input\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nSample Output\n1 2 5 6\nExplanation\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nFrom the top, only nodes are visible.",
        "156": "Given a pointer to the root of a binary tree, you need to print the level order traversal of this tree. In level-order traversal, nodes are visited level by level from left to right. Complete the function and print the values in a single line separated by a space.\nFor example:\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nFor the above tree, the level order traversal is .\nInput Format\nYou are given a function,\nvoid levelOrder(Node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values in a single line separated by a space.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 6 4\nExplanation\nWe need to print the nodes level by level. We process each level from left to right.\nLevel Order Traversal: .",
        "157": "You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function.\nInput Format\nYou are given a function,\nNode * insert (Node * root ,int data) {\n\n}\nConstraints\nNo. of nodes in the tree 500\nOutput Format\nReturn the root of the binary search tree after inserting the value into the tree.\nSample Input\n        4\n       \/ \\\n      2   7\n     \/ \\\n    1   3\nThe value to be inserted is 6.\nSample Output\n         4\n       \/   \\\n      2     7\n     \/ \\   \/\n    1   3 6",
        "158": "Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit. If they are on the left side of the tree, they will be a 0 (zero). If on the right, they'll be a 1 (one). Only the leaves will contain a letter and its frequency count. All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.\nFor instance, consider the string ABRACADABRA. There are a total of characters in the string. This number should match the count in the ultimately determined root of the tree. Our frequencies are and . The two smallest frequencies are for and , both equal to , so we'll create a tree with them. The root node will contain the sum of the counts of its descendants, in this case . The left node will be the first character encountered, , and the right will contain . Next we have items with a character count of : the tree we just created, the character and the character . The tree came first, so it will go on the left of our new root node. will go on the right. Repeat until the tree is complete, then fill in the 's and 's for the edges. The finished graph looks like:\nInput characters are only present in the leaves. Internal nodes have a character value of \u03d5 (NULL). We can determine that our values for characters are:\nA - 0\nB - 111\nC - 1100\nD - 1101\nR - 10\nOur Huffman encoded string is:\nA B    R  A C     A D     A B    R  A\n0 111 10 0 1100 0 1101 0 111 10 0\nor\n01111001100011010111100\nTo avoid ambiguity, Huffman encoding is a prefix free encoding technique. No codeword appears as a prefix of any other codeword.\nTo decode the encoded string, follow the zeros and ones to a leaf and return the character there.\nYou are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.\nFunction Description\nComplete the function decode_huff in the editor below. It must return the decoded string.\ndecode_huff has the following parameters:\nroot: a reference to the root node of the Huffman tree\ns: a Huffman encoded string\nInput Format\nThere is one line of input containing the plain string, . Background code creates the Huffman tree then passes the head node and the encoded string to the function.\nConstraints\nOutput Format\nOutput the decoded string on a single line.\nSample Input\ns=\"1001011\"\nSample Output\nABACA\nExplanation\nS=\"1001011\"\nProcessing the string from left to right.\nS[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[1]='0' : we move to the left child. \nS[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.\nWe move back to the root.\n\nS[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[4]='0' : we move to the left child. \nS[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.\nWe move back to the root.\n\n S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nDecoded String = \"ABACA\"",
        "159": "You are given pointer to the root of the binary search tree and two values and . You need to return the lowest common ancestor (LCA) of and in the binary search tree.\n\nIn the diagram above, the lowest common ancestor of the nodes and is the node . Node is the lowest node which has nodes and as descendants.\nFunction Description\nComplete the function lca in the editor below. It should return a pointer to the lowest common ancestor node of the two values given.\nlca has the following parameters:\n- root: a pointer to the root node of a binary search tree\n- v1: a node.data value\n- v2: a node.data value\nInput Format\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers representing values.\nThe third line contains two space-separated integers, and .\nTo use the test data, you will have to create the binary search tree yourself. Here on the platform, the tree will be created for you.\nConstraints\n\n\n\nThe tree will contain nodes with data equal to and .\nOutput Format\nReturn the a pointer to the node that is the lowest common ancestor of and .\nSample Input\n6\n4 2 3 1 7 6\n1 7\nand .\nSample Output\n[reference to node 4]\nExplanation\nLCA of and is , the root in this case.\nReturn a pointer to the node.",
        "160": "A binary tree is a tree which is characterized by one of the following properties:\nIt can be empty (null).\nIt contains a root node only.\nIt contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees.\nIn-order traversal is performed as\nTraverse the left subtree.\nVisit root.\nTraverse the right subtree.\nFor this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf. When you reach a leaf, back up to its parent, check for a right child and visit it if there is one. If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner. Keep doing this until you have traversed the entire tree. You will only store the values of a node as you visit when one of the following is true:\nit is the first node visited, the first time visited\nit is a leaf, should only be visited once\nall of its subtrees have been explored, should only be visited once while this is true\nit is the root of the tree, the first time visited\nSwapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L.\nFor example, in the following tree, we swap children of node 1.\n                                Depth\n    1               1            [1]\n   \/ \\             \/ \\\n  2   3     ->    3   2          [2]\n   \\   \\           \\   \\\n    4   5           5   4        [3]\nIn-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4.\nSwap operation:\nWe define depth of a node as follows:\nThe root node is at depth 1.\nIf the depth of the parent node is d, then the depth of current node will be d+1.\nGiven a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h \u2208 [k, 2k, 3k,...]. In other words, if h is a multiple of k, swap the left and right subtrees of that level.\nYou are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree.\nFunction Description\nComplete the swapNodes function in the editor below. It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation.\nswapNodes has the following parameter(s):\n- indexes: an array of integers representing index values of each , beginning with , the first element, as the root.\n- queries: an array of integers, each representing a value.\nInput Format\nThe first line contains n, number of nodes in the tree.\nEach of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.\nNote: -1 is used to represent a null node.\nThe next line contains an integer, t, the size of .\nEach of the next t lines contains an integer , each being a value .\nOutput Format\nFor each k, perform the swap operation and store the indices of your in-order traversal to your result array. After all swap operations have been performed, return your result array for printing.\nConstraints\nEither or\nEither or\nThe index of a non-null child will always be greater than that of its parent.\nSample Input 0\n3\n2 3\n-1 -1\n-1 -1\n2\n1\n1\nSample Output 0\n3 1 2\n2 1 3\nExplanation 0\nAs nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.\n    1   [s]       1    [s]       1   \n   \/ \\      ->   \/ \\        ->  \/ \\  \n  2   3 [s]     3   2  [s]     2   3\nNote: [s] indicates that a swap operation is done at this depth.\nSample Input 1\n5\n2 3\n-1 4\n-1 5\n-1 -1\n-1 -1\n1\n2\nSample Output 1\n4 2 1 5 3\nExplanation 1\nSwapping child nodes of node 2 and 3 we get\n    1                  1  \n   \/ \\                \/ \\ \n  2   3   [s]  ->    2   3\n   \\   \\            \/   \/ \n    4   5          4   5  \nSample Input 2\n11\n2 3\n4 -1\n5 -1\n6 -1\n7 8\n-1 9\n-1 -1\n10 11\n-1 -1\n-1 -1\n-1 -1\n2\n2\n4\nSample Output 2\n2 9 6 4 1 3 7 5 11 8 10\n2 6 9 4 1 3 7 5 10 8 11\nExplanation 2\nHere we perform swap operations at the nodes whose depth is either 2 or 4 for and then at nodes whose depth is 4 for .\n         1                     1                          1             \n        \/ \\                   \/ \\                        \/ \\            \n       \/   \\                 \/   \\                      \/   \\           \n      2     3    [s]        2     3                    2     3          \n     \/      \/                \\     \\                    \\     \\         \n    \/      \/                  \\     \\                    \\     \\        \n   4      5          ->        4     5          ->        4     5       \n  \/      \/ \\                  \/     \/ \\                  \/     \/ \\      \n \/      \/   \\                \/     \/   \\                \/     \/   \\     \n6      7     8   [s]        6     7     8   [s]        6     7     8\n \\          \/ \\            \/           \/ \\              \\         \/ \\   \n  \\        \/   \\          \/           \/   \\              \\       \/   \\  \n   9      10   11        9           11   10              9     10   11 ",
        "161": "Kitty has a tree, , consisting of nodes where each node is uniquely labeled from to . Her friend Alex gave her sets, where each set contains distinct nodes. Kitty needs to calculate the following expression on each set:\nwhere:\ndenotes an unordered pair of nodes belonging to the set.\ndenotes the number of edges on the unique (shortest) path between nodes and .\nGiven and sets of distinct nodes, calculate the expression for each set. For each set of nodes, print the value of the expression modulo on a new line.\nExample\n\nThe graph looks like this:\n\nThere are three pairs that can be created from the query set: . The distance from to is , from to is , and from to is .\nNow do the summation:\nInput Format\nThe first line contains two space-separated integers, the respective values of (the number of nodes in tree ) and (the number of nodes in the query set).\nEach of the subsequent lines contains two space-separated integers, and , that describe an undirected edge between nodes and .\nThe subsequent lines define each set over two lines in the following format:\nThe first line contains an integer, , the size of the set.\nThe second line contains space-separated integers, the set's elements.\nConstraints\nThe sum of over all does not exceed .\nAll elements in each set are distinct.\nSubtasks\nfor of the maximum score.\nfor of the maximum score.\nfor of the maximum score.\nOutput Format\nPrint lines of output where each line contains the expression for the query, modulo .\nSample Input 0\n7 3\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n2\n2 4\n1\n5\n3\n2 4 5\nSample Output 0\n16\n0\n106\nExplanation 0\nTree looks like this:\nWe perform the following calculations for sets:\nSet : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:\nSet : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print on a new line.\nSet : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:",
        "162": "For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements:\nThe value of every node in a node's left subtree is less than the data value of that node.\nThe value of every node in a node's right subtree is greater than the data value of that node.\nGiven the root node of a binary tree, can you determine if it's also a binary search tree?\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.\nInput Format\nYou are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument.\nConstraints\nOutput Format\nYou are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line.\nSample Input\nSample Output\nNo",
        "163": "The square-ten tree decomposition of an array is defined as follows:\nThe lowest () level of the square-ten tree consists of single array elements in their natural order.\nThe level (starting from ) of the square-ten tree consists of subsequent array subsegments of length in their natural order. Thus, the level contains subsegments of length , the level contains subsegments of length , the level contains subsegments of length , etc.\nIn other words, every level (for every ) of square-ten tree consists of array subsegments indexed as:\nLevel consists of array subsegments indexed as .\nThe image below depicts the bottom-left corner (i.e., the first array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:\nTask\nGiven the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence such as for every , , , where every belongs to any of the square-ten tree levels and is minimal amongst all such variants.\nInput Format\nThe first line contains a single integer denoting .\nThe second line contains a single integer denoting .\nConstraints\nThe numbers in input do not contain leading zeroes.\nOutput Format\nAs soon as array indices are too large, you should find a sequence of square-ten tree level numbers, , meaning that subsegment belongs to the level of the square-ten tree.\nPrint this sequence in the following compressed format:\nOn the first line, print the value of (i.e., the compressed sequence block count).\nFor each of the subsequent lines, print space-separated integers, and (, ), meaning that the number appears consequently times in sequence . Blocks should be listed in the order they appear in the sequence. In other words, should be equal to , should be equal to , etc.\nThus must be true and must be true for every . All numbers should be printed without leading zeroes.\nSample Input 0\n1\n10\nSample Output 0\n1\n1 1\nExplanation 0\nSegment belongs to level of the square-ten tree.",
        "164": "Greg has a tree of nodes containing integer data. He wants to insert a node with some non-zero integer value somewhere into the tree. His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount. This is called a balanced forest. Being frugal, the data value he inserts should be minimal. Determine the minimal amount that a new node can have to allow creation of a balanced forest. If it's not possible to create a balanced forest, return -1.\nFor example, you are given node values and . It is the following tree:\nThe blue node is root, the first number in a node is node number and the second is its value. Cuts can be made between nodes and and nodes and to have three trees with sums , and . Adding a new node of to the third tree completes the solution.\nFunction Description\nComplete the balancedForest function in the editor below. It must return an integer representing the minimum value of that can be added to allow creation of a balanced forest, or if it is not possible.\nbalancedForest has the following parameter(s):\nc: an array of integers, the data values for each node\nedges: an array of 2 element arrays, the node pairs per edge\nInput Format\nThe first line contains a single integer, , the number of queries.\nEach of the following sets of lines is as follows:\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers describing the respective values of , where each denotes the value at node .\nEach of the following lines contains two space-separated integers, and , describing edge connecting nodes and .\nConstraints\nEach query forms a valid undirected tree.\nSubtasks\nFor of the maximum score:\nFor of the maximum score:\nOutput Format\nFor each query, return the minimum value of the integer . If no such value exists, return instead.\nSample Input\n2\n5\n1 2 2 1 1\n1 2\n1 3\n3 5\n1 4\n3\n1 3 5\n1 3\n1 2\nSample Output\n2\n-1\nExplanation\nWe perform the following two queries:\nThe tree initially looks like this:\n\nGreg can add a new node with and create a new edge connecting nodes and . Then he cuts the edge connecting nodes and and the edge connecting nodes and . We now have a three-tree balanced forest where each tree has a sum of .\nIn the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .",
        "165": "Jenny loves experimenting with trees. Her favorite tree has nodes connected by edges, and each edge is unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius from this tree by performing the following two steps:\nChoose a node, , from the tree.\nCut a subtree consisting of all nodes which are not further than units from node .\nFor example, the blue nodes in the diagram below depict a subtree centered at that has radius :\nGiven , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not isomorphic.\nInput Format\nThe first line contains two space-separated integers denoting the respective values of and .\nEach of the next subsequent lines contains two space-separated integers, and , describing a bidirectional edge in Jenny's tree having length .\nConstraints\nSubtasks\nFor of the max score:\nOutput Format\nPrint the total number of different possible subtrees.\nSample Input 0\n7 1\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\nSample Output 0\n3\nExplanation 0\nIn the diagram below, blue nodes denote the possible subtrees:\nThe last subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print as our answer.\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\nSample Output 1\n4\nExplanation 1\nIn the diagram below, blue nodes denote the possible subtrees:\nHere, we have four possible different subtrees.",
        "166": "We consider metric space to be a pair, , where is a set and such that the following conditions hold:\nwhere is the distance between points and .\nLet's define the product of two metric spaces, , to be such that:\n, where , .\nSo, it follows logically that is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: .\nFor example, , where is a metric space. , where .\nIn this challenge, we need a tree-space. You're given a tree, , where is the set of vertices and is the set of edges. Let the function be the distance between two vertices in tree (i.e., is the number of edges on the path between vertices and ). Note that is a metric space.\nYou are given a tree, , with vertices, as well as points in . Find and print the distance between the two furthest points in this metric space!\nInput Format\nThe first line contains two space-separated positive integers describing the respective values of (the number of vertices in ) and (the number of given points).\nEach line of the subsequent lines contains two space-separated integers, and , describing edge in .\nEach line of the subsequent lines contains two space-separated integers describing the respective values of and for point .\nConstraints\nScoring\nThis challenge uses binary scoring, so you must pass all test cases to earn a positive score.\nOutput Format\nPrint a single non-negative integer denoting the maximum distance between two of the given points in metric space .\nSample Input 0\n2 2\n1 2\n1 2\n2 1\nSample Output 0\n2\nExplanation 0\nThe distance between points and is .\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n3 6\n4 5\n5 5\nSample Output 1\n3\nExplanation 1\nThe best points are and , which gives us a distance of .",
        "167": "Consider an array of integers, . Find and print the total number of pairs such that where .\nInput Format\nThe first line contains an integer, , denoting the number of elements in the array.\nThe second line consists of space-separated integers describing the respective values of .\nConstraints\nScoring\nfor of the test cases.\nfor of the test cases.\nfor of the test cases.\nOutput Format\nPrint a long integer denoting the total number pairs satisfying where .\nSample Input\n5  \n1 1 2 4 2\nSample Output\n8\nExplanation\nThere are eight pairs of indices satisfying the given criteria: , , , , , , , and . Thus, we print as our answer.",
        "168": "An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.\nWe define balance factor for each node as :\nbalanceFactor = height(left subtree) - height(right subtree)\nThe balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than \u22121 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.\n(https:\/\/en.wikipedia.org\/wiki\/AVL_tree)\nYou are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.\nInput Format\nYou are given a function,\nnode *insert(node * root,int new_val)\n{\n\n\n}\n'node' is defined as :\nstruct node\n{\nint val;            \/\/value\nstruct node* left;  \/\/left child\nstruct node* right; \/\/right child\nint ht;             \/\/height of the node\n} node;\nYou only need to complete the function.\nNote: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.\n\nOutput Format\nInsert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced.\nSample Input\n    3\n  \/  \\\n 2    4\n       \\\n        5\nThe value to be inserted is 6.\nSample Output\n    3\n  \/  \\\n 2    5\n     \/ \\\n    4   6\nExplanation\nAfter inserting 6 in the tree. the tree becomes:\n    3 (Balance Factor = -2)\n  \/  \\\n 2    4 (Balance Factor = -2)\n       \\\n        5 (Balance Factor = -1)\n         \\\n          6 (Balance Factor = 0)\nBalance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree.\nAfter performing the rotation, the tree becomes :\n                              3 (Balance Factor = -1)\n                            \/   \\\n      (Balance Factor = 0) 2     5 (Balance Factor = 0)\n                                \/ \\\n           (Balance Factor = 0)4   6 (Balance Factor = 0)",
        "169": "Given two numbers and . indicates the number of elements in the array and indicates number of queries. You need to perform two types of queries on the array .\nYou are given queries. Queries can be of two types, type 1 and type 2.\nType 1 queries are represented as 1 i j : Modify the given array by removing elements from to and adding them to the front.\nType 2 queries are represented as 2 i j : Modify the given array by removing elements from to and adding them to the back.\nYour task is to simply print of the resulting array after the execution of queries followed by the resulting array.\nNote While adding at back or front the order of elements is preserved.\nInput Format\nFirst line consists of two space-separated integers, and .\nSecond line contains integers, which represent the elements of the array.\nqueries follow. Each line contains a query of either type 1 or type 2 in the form\nConstraints\n\n\nOutput Format\nPrint the absolute value i.e. in the first line.\nPrint elements of the resulting array in the second line. Each element should be seperated by a single space.\nSample Input\n8 4\n1 2 3 4 5 6 7 8\n1 2 4\n2 3 5\n1 4 7\n2 1 4\nSample Output\n1\n2 3 6 5 7 8 4 1\nExplanation\nGiven array is .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nNow is i.e. and the array is",
        "170": "The median of numbers is defined as the middle number after sorting them in order if is odd. Or it is the average of the middle two numbers if is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median.\nExample:\nFor a set of numbers the median is the third number in the sorted set , which is . Similarly, for a set of numbers, , the median is the average of the second and the third element in the sorted set , which is .  \nInput:\nThe first line is an integer, , that indicates the number of operations. Each of the next lines is either a x or r x. a x indicates that is added to the set, and r x indicates that is removed from the set.\nOutput:\nFor each operation: If the operation is add, output the median after adding in a single line. If the operation is remove and the number is not in the list, output Wrong! in a single line. If the operation is remove and the number is in the list, output the median after deleting in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.)\nNote\nIf your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong!\nConstraints:\n\nFor each a x or r x, will always be a signed integer (which will fit in 32 bits).\nSample Input:\n7  \nr 1  \na 1  \na 2  \na 1  \nr 1  \nr 2  \nr 1  \nSample Output:\nWrong!  \n1  \n1.5  \n1  \n1.5  \n1  \nWrong!\nNote: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!. ",
        "171": "People connect with each other in a social network. A connection between Person and Person is represented as . When two persons belonging to different communities connect, the net effect is the merge the communities which and belong to.\nAt the beginning, there are people representing communities. Suppose person and connected and later and connected, then ,, and will belong to the same community.\nThere are two types of queries:\ncommunities containing persons and are merged if they belong to different communities.\nprint the size of the community to which person belongs.\nInput Format\nThe first line of input contains 2 space-separated integers and , the number of people and the number of queries.\nThe next lines will contain the queries.\nConstraints\n\nOutput Format\nThe output of the queries.\nSample Input\nSTDIN Function ----- -------- 3 6 n = 3, q = 6 Q 1 print the size of the community containing person 1 M 1 2 merge the communities containing persons 1 and 2 ... Q 2 M 2 3 Q 3 Q 2\nSample Output\n1\n2\n3\n3\nExplanation\nInitial size of each of the community is .",
        "172": "This question is designed to help you get a better understanding of basic heap operations.\nThere are types of query:\n\" \" - Add an element to the heap.\n\" \" - Delete the element from the heap.\n\"\" - Print the minimum of all the elements in the heap.\nNOTE: It is guaranteed that the element to be deleted will be there in the heap. Also, at any instant, only distinct elements will be in the heap.\nInput Format\nThe first line contains the number of queries, .\nEach of the next lines contains one of the types of query.\nConstraints\n\nOutput Format\nFor each query of type , print the minimum value on a single line.\nSample Input\nSTDIN       Function\n-----       --------\n5           Q = 5\n1 4         insert 4\n1 9         insert 9\n3           print minimum\n2 4         delete 4\n3           print minimum\nSample Output\n4  \n9 \nExplanation\nAfter the first queries, the heap contains {}. Printing the minimum gives as the output. Then, the query deletes from the heap, and the query gives as the output.",
        "173": "You have an empty sequence, and you will be given queries. Each query is one of these three types:\n1 x  -Push the element x into the stack.\n2    -Delete the element present at the top of the stack.\n3    -Print the maximum element in the stack.\nFunction Description\nComplete the getMax function in the editor below.\ngetMax has the following parameters:\n- string operations[n]: operations as strings\nReturns\n- int[]: the answers to each type 3 query\nInput Format\nThe first line of input contains an integer, . The next lines each contain an above mentioned query.\nConstraints\nConstraints\n\n\n\nAll queries are valid.\nSample Input\nSTDIN   Function\n-----   --------\n10      operations[] size n = 10\n1 97    operations = ['1 97', '2', '1 20', ....]\n2\n1 20\n2\n1 26\n1 20\n2\n3\n1 91\n3\nSample Output\n26\n91",
        "174": "A queue is an abstract data type that maintains the order in which elements were added to it, allowing the oldest elements to be removed from the front and new elements to be added to the rear. This is called a First-In-First-Out (FIFO) data structure because the first element added to the queue (i.e., the one that has been waiting the longest) is always the first one to be removed.\nA basic queue has the following operations:\nEnqueue: add a new element to the end of the queue.\nDequeue: remove the element from the front of the queue and return it.\nIn this challenge, you must first implement a queue using two stacks. Then process queries, where each query is one of the following types:\n1 x: Enqueue element into the end of the queue.\n2: Dequeue the element at the front of the queue.\n3: Print the element at the front of the queue.\nInput Format\nThe first line contains a single integer, , denoting the number of queries.\nEach line of the subsequent lines contains a single query in the form described in the problem statement above. All three queries start with an integer denoting the query , but only query is followed by an additional space-separated value, , denoting the value to be enqueued.\nConstraints\nIt is guaranteed that a valid answer always exists for each query of type .\nOutput Format\nFor each query of type , print the value of the element at the front of the queue on a new line.\nSample Input\nSTDIN   Function\n-----   --------\n10      q = 10 (number of queries)\n1 42    1st query, enqueue 42\n2       dequeue front element\n1 14    enqueue 42\n3       print the front element\n1 28    enqueue 28\n3       print the front element\n1 60    enqueue 60\n1 78    enqueue 78\n2       dequeue front element\n2       dequeue front element\nSample Output\n14\n14\nExplanation\nPerform the following sequence of actions:\nEnqueue ; .\nDequeue the value at the head of the queue, ; .\nEnqueue ; .\nPrint the value at the head of the queue, ; .\nEnqueue ; .\nPrint the value at the head of the queue, ; .\nEnqueue ; .\nEnqueue ; .\nDequeue the value at the head of the queue, ; .\nDequeue the value at the head of the queue, ; .",
        "175": "There are nodes in an undirected graph, and a number of edges connecting some nodes. In each edge, the first value will be between and , inclusive. The second node will be between and , inclusive. Given a list of edges, determine the size of the smallest and largest connected components that have or more nodes. A node can have any number of connections. The highest node value will always be connected to at least other node.\nNote Single nodes should not be considered in the answer.\nExample\n\nThe smaller component contains nodes and the larger contains . Return the array .\nFunction Description\nComplete the connectedComponents function in the editor below.\nconnectedComponents has the following parameter(s):\n- int bg[n][2]: a 2-d array of integers that represent node ends of graph edges\nReturns\n- int[2]: an array with 2 integers, the smallest and largest component sizes\nInput Format\nThe first line contains an integer , the size of .\nEach of the next lines contain two space-separated integers, and .\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n5       bg[] size n = 5\n1 6     bg = [[1, 6],[2, 7], [3, 8], [4,9], [2, 6]]\n2 7\n3 8\n4 9\n2 6\nSample Output\n2 4\nExplanation\nSince the component with node contains only one node, it is not considered.\nThe number of vertices in the smallest connected component in the graph is based on either or .\nThe number of vertices in the largest connected component in the graph is i.e. .",
        "176": "A bracket is considered to be any one of the following characters: (, ), {, }, [, or ].\nTwo brackets are considered to be a matched pair if the an opening bracket (i.e., (, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. There are three types of matched pairs of brackets: [], {}, and ().\nA matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, {[(])} is not balanced because the contents in between { and } are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single, unbalanced closing square bracket, ].\nBy this logic, we say a sequence of brackets is balanced if the following conditions are met:\nIt contains no unmatched brackets.\nThe subset of brackets enclosed within the confines of a matched pair of brackets is also a matched pair of brackets.\nGiven strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, return YES. Otherwise, return NO.\nFunction Description\nComplete the function isBalanced in the editor below.\nisBalanced has the following parameter(s):\nstring s: a string of brackets\nReturns\nstring: either YES or NO\nInput Format\nThe first line contains a single integer , the number of strings.\nEach of the next lines contains a single string , a sequence of brackets.\nConstraints\n, where is the length of the sequence.\nAll chracters in the sequences \u2208 { {, }, (, ), [, ] }.\nOutput Format\nFor each string, return YES or NO.\nSample Input\nSTDIN           Function\n-----           --------\n3               n = 3\n{[()]}          first s = '{[()]}'\n{[(])}          second s = '{[(])}'\n{{[[(())]]}}    third s ='{{[[(())]]}}'\nSample Output\nYES\nNO\nYES\nExplanation\nThe string {[()]} meets both criteria for being a balanced string.\nThe string {[(])} is not balanced because the brackets enclosed by the matched pair { and } are not balanced: [(]).\nThe string {{[[(())]]}} meets both criteria for being a balanced string.",
        "177": "You are given a square grid with some cells open (.) and some blocked (X). Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell. Given a grid, a start and a goal, determine the minmum number of moves to get to the goal.\nExample.\n\n\n\n\nThe grid is shown below:\n...\n.X.\n...\nThe starting position so start in the top left corner. The goal is . The path is . It takes moves to reach the goal.\nFunction Description\nComplete the minimumMoves function in the editor.\nminimumMoves has the following parameter(s):\nstring grid[n]: an array of strings that represent the rows of the grid\nint startX: starting X coordinate\nint startY: starting Y coordinate\nint goalX: ending X coordinate\nint goalY: ending Y coordinate\nReturns\nint: the minimum moves to reach the goal\nInput Format\nThe first line contains an integer , the size of the array grid.\nEach of the next lines contains a string of length .\nThe last line contains four space-separated integers,\nConstraints\nSample Input\nSTDIN       FUNCTION\n-----       --------\n3           grid[] size n = 3\n.X.         grid = ['.X.','.X.', '...']\n.X.\n...\n0 0 0 2     startX = 0, startY = 0, goalX = 0, goalY = 2\nSample Output\n3\nExplanation\nHere is a path that one could follow in order to reach the destination in steps:\n.",
        "178": "Jesse loves cookies and wants the sweetness of some cookies to be greater than value . To do this, two cookies with the least sweetness are repeatedly mixed. This creates a special combined cookie with:\nsweetness Least sweet cookie 2nd least sweet cookie).\nThis occurs until all the cookies have a sweetness .\nGiven the sweetness of a number of cookies, determine the minimum number of operations required. If it is not possible, return .\nExample\n\nThe smallest values are .\nRemove them then return to the array. Now .\nRemove and return to the array. Now .\nRemove , return and .\nFinally, remove and return to . Now .\nAll values are so the process stops after iterations. Return .\nFunction Description\nComplete the cookies function in the editor below.\ncookies has the following parameters:\nint k: the threshold value\nint A[n]: an array of sweetness values\nReturns\nint: the number of iterations required or\nInput Format\nThe first line has two space-separated integers, and , the size of and the minimum required sweetness respectively.\nThe next line contains space-separated integers, .\nConstraints\n\n\nSample Input\nSTDIN               Function\n-----               --------\n6 7                 A[] size n = 6, k = 7\n1 2 3 9 10 12       A = [1, 2, 3, 9, 10, 12]  \nSample Output\n2\nExplanation\nCombine the first two cookies to create a cookie with sweetness =\nAfter this operation, the cookies are .\nThen, combine the cookies with sweetness and sweetness , to create a cookie with resulting sweetness =\nNow, the cookies are .\nAll the cookies have a sweetness .\n\nThus, operations are required to increase the sweetness.",
        "179": "Kundu is true tree lover. Tree is a connected graph having N vertices and N-1 edges. Today when he got a tree, he colored each edge with one of either red(r) or black(b) color. He is interested in knowing how many triplets(a,b,c) of vertices are there , such that, there is atleast one edge having red color on all the three paths i.e. from vertex a to b, vertex b to c and vertex c to a . Note that (a,b,c), (b,a,c) and all such permutations will be considered as the same triplet.\nIf the answer is greater than 109 + 7, print the answer modulo (%) 109 + 7.\nInput Format\nThe first line contains an integer N, i.e., the number of vertices in tree.\nThe next N-1 lines represent edges: 2 space separated integers denoting an edge followed by a color of the edge. A color of an edge is denoted by a small letter of English alphabet, and it can be either red(r) or black(b).\nOutput Format\nPrint a single number i.e. the number of triplets.\nConstraints\n1 \u2264 N \u2264 105\nA node is numbered between 1 to N.\nSample Input\n5\n1 2 b\n2 3 r\n3 4 r\n4 5 b\nSample Output\n4\nExplanation\nGiven tree is something like this.\n(2,3,4) is one such triplet because on all paths i.e 2 to 3, 3 to 4 and 2 to 4 there is atleast one edge having red color.\n(2,3,5), (1,3,4) and (1,3,5) are other such triplets.\nNote that (1,2,3) is NOT a triplet, because the path from 1 to 2 does not have an edge with red color.",
        "180": "An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index, (where ), that can be referenced as or .\nReverse an array of integers.\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\nExample\nReturn .\nFunction Description\nComplete the function reverseArray in the editor below.\nreverseArray has the following parameter(s):\nint A[n]: the array to reverse\nReturns\nint[n]: the reversed array\nInput Format\nThe first line contains an integer, , the number of integers in .\nThe second line contains space-separated integers that make up .\nConstraints",
        "181": "Given a 2D Array, :\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\nAn hourglass in is a subset of values with indices falling in this pattern in 's graphical representation:\na b c\n  d\ne f g\nThere are hourglasses in . An hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in , then print the maximum hourglass sum. The array will always be .\nExample\n-9 -9 -9  1 1 1 \n 0 -9  0  4 3 2\n-9 -9 -9  1 2 3\n 0  0  8  6 6 0\n 0  0  0 -2 0 0\n 0  0  1  2 4 0\nThe hourglass sums are:\n-63, -34, -9, 12, \n-10,   0, 28, 23, \n-27, -11, -2, 10, \n  9,  17, 25, 18\nThe highest hourglass sum is from the hourglass beginning at row , column :\n0 4 3\n  1\n8 6 6\nNote: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.\nFunction Description\nComplete the function hourglassSum in the editor below.\nhourglassSum has the following parameter(s):\nint arr[6][6]: an array of integers\nReturns\nint: the maximum hourglass sum\nInput Format\nEach of the lines of inputs contains space-separated integers .\nConstraints\nOutput Format\nPrint the largest (maximum) hourglass sum found in .\nSample Input\n1 1 1 0 0 0\n0 1 0 0 0 0\n1 1 1 0 0 0\n0 0 2 4 4 0\n0 0 0 2 0 0\n0 0 1 2 4 0\nSample Output\n19\nExplanation\ncontains the following hourglasses:\nThe hourglass with the maximum sum () is:\n2 4 4\n  2\n1 2 4",
        "182": "Declare a 2-dimensional array, , of empty arrays. All arrays are zero indexed.\nDeclare an integer, , and initialize it to .\nThere are types of queries, given as an array of strings for you to parse:\nQuery: 1 x y\nLet .\nAppend the integer to .\nQuery: 2 x y\nLet .\nAssign the value to .\nStore the new value of to an answers array.\nNote: is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. is the modulo operator.\nFinally, size(arr[idx]) is the number of elements in arr[idx]\nFunction Description\nComplete the dynamicArray function below.\ndynamicArray has the following parameters:\n- int n: the number of empty arrays to initialize in\n- string queries[q]: query strings that contain 3 space-separated integers\nReturns\nint[]: the results of each type 2 query in the order they are presented\nInput Format\nThe first line contains two space-separated integers, , the size of to create, and , the number of queries, respectively.\nEach of the subsequent lines contains a query string, .\nConstraints\nIt is guaranteed that query type will never query an empty array or index.\nSample Input\n2 5\n1 0 5\n1 1 7\n1 0 3\n2 1 0\n2 1 1\nSample Output\n7\n3\nExplanation\nInitial Values:\n\n\n= [ ]\n= [ ]\nQuery 0: Append to .\n\n= [5]\n= [ ]\nQuery 1: Append to .\n= [5]\n= [7]\nQuery 2: Append to .\n\n= [5, 3]\n= [7]\nQuery 3: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n7\nQuery 4: Assign the value at index of to , print .\n\n= [5, 3]\n= [7]\n3",
        "183": "A left rotation operation on an array of size shifts each of the array's elements unit to the left. Given an integer, , rotate the array that many steps left and return the result.\nExample\n\nAfter rotations, .\nFunction Description\nComplete the rotateLeft function in the editor below.\nrotateLeft has the following parameters:\nint d: the amount to rotate by\nint arr[n]: the array to rotate\nReturns\nint[n]: the rotated array\nInput Format\nThe first line contains two space-separated integers that denote , the number of integers, and , the number of left rotations to perform.\nThe second line contains space-separated integers that describe .\nConstraints\nSample Input\n5 4\n1 2 3 4 5\nSample Output\n5 1 2 3 4\nExplanation\nTo perform left rotations, the array undergoes the following sequence of changes:",
        "184": "There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings. Return an array of the results.\nExample\n\nThere are instances of '', of '' and of ''. For each query, add an element to the return array, .\nFunction Description\nComplete the function matchingStrings in the editor below. The function must return an array of integers representing the frequency of occurrence of each query string in stringList.\nmatchingStrings has the following parameters:\nstring stringList[n] - an array of strings to search\nstring queries[q] - an array of query strings\nReturns\nint[q]: an array of results for each query\nInput Format\nThe first line contains and integer , the size of .\nEach of the next lines contains a string .\nThe next line contains , the size of .\nEach of the next lines contains a string .\nConstraints\n\n\n.",
        "185": "Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each the array element between two given indices, inclusive. Once all operations have been performed, return the maximum value in the array.\nExample\n\nQueries are interpreted as follows:\n    a b k\n    1 5 3\n    4 8 7\n    6 9 1\nAdd the values of between the indices and inclusive:\nindex->  1 2 3  4  5 6 7 8 9 10\n [0,0,0, 0, 0,0,0,0,0, 0]\n [3,3,3, 3, 3,0,0,0,0, 0]\n [3,3,3,10,10,7,7,7,0, 0]\n [3,3,3,10,10,8,8,8,1, 0]\nThe largest value is after all operations are performed.\nFunction Description\nComplete the function arrayManipulation in the editor below.\narrayManipulation has the following parameters:\nint n - the number of elements in the array\nint queries[q][3] - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.\nReturns\nint - the maximum value in the resultant array\nInput Format\nThe first line contains two space-separated integers and , the size of the array and the number of operations.\nEach of the next lines contains three space-separated integers , and , the left index, right index and summand.\nConstraints\nSample Input\n5 3\n1 2 100\n2 5 100\n3 4 100\nSample Output\n200\nExplanation\nAfter the first update the list is 100 100 0 0 0.\nAfter the second update list is 100 200 100 100 100.\nAfter the third update list is 100 200 200 200 100.\nThe maximum value is .",
        "186": null,
        "187": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nYou are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.\nFunction Description\nComplete the insertNodeAtTail function in the editor below.\ninsertNodeAtTail has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nint data: the data value for the node to insert\nReturns\nSinglyLinkedListNode pointer: reference to the head of the modified linked list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each, the value that needs to be inserted at tail.\nConstraints\nSample Input\nSTDIN Function ----- -------- 5 size of linked list n = 5 141 linked list data values 141..474 302 164 530 474\nSample Output\n141\n302\n164\n530\n474\nExplanation\nFirst the linked list is NULL. After inserting 141, the list is 141 -> NULL.\nAfter inserting 302, the list is 141 -> 302 -> NULL.\nAfter inserting 164, the list is 141 -> 302 -> 164 -> NULL.\nAfter inserting 530, the list is 141 -> 302 -> 164 -> 530 -> NULL. After inserting 474, the list is 141 -> 302 -> 164 -> 530 -> 474 -> NULL, which is the final list.",
        "188": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a linked list, insert a new node before the head. The value in the new node should point to and the value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\nFunction Description\nComplete the function insertNodeAtHead in the editor below.\ninsertNodeAtHead has the following parameter(s):\nSinglyLinkedListNode llist: a reference to the head of a list\ndata: the value to insert in the field of the new node\nInput Format\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next lines contain an integer each, the elements to be inserted, one per function call.\nConstraints\nSample Input\n5\n383\n484\n392\n975\n321\nSample Output\n321\n975\n392\n484\n383\nExplanation\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "189": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list and an integer to insert at a certain position, create a new node with the given integer as its attribute, insert this node at the desired position and return the head node.\nA position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.\nExample\nrefers to the first node in the list\n\nInsert a node at position with . The new list is\nFunction Description Complete the function insertNodeAtPosition in the editor below. It must return a reference to the head node of your finished list.\ninsertNodeAtPosition has the following parameters:\nhead: a SinglyLinkedListNode pointer to the head of the list\ndata: an integer value to insert as data in your new node\nposition: an integer position to insert the new node, zero based indexing\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer SinglyLinkedListNode[i].data.\nThe next line contains an integer , the data of the node that is to be inserted.\nThe last line contains an integer .\nConstraints\n, where is the element of the linked list.\n.\nSample Input\n3\n16\n13\n7\n1\n2\nSample Output\n16 13 1 7\nExplanation\nThe initial linked list is . Insert at the position which currently has in it. The updated linked list is .",
        "190": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nDelete the node at a given position in a linked list and return a reference to the head node. The head is at position 0. The list may be empty after you delete the node. In that case, return a null value.\nExample\n\nAfter removing the node at position , .\nFunction Description\nComplete the deleteNode function in the editor below.\ndeleteNode has the following parameters:\n- SinglyLinkedListNode pointer llist: a reference to the head node in the list\n- int position: the position of the node to remove\nReturns\n- SinglyLinkedListNode pointer: a reference to the head of the modified list\nInput Format\nThe first line of input contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the node data values in order.\nThe last line contains an integer, , the position of the node to delete.\nConstraints\n, where is the element of the linked list.\nSample Input\n8\n20\n6\n2\n19\n7\n4\n15\n9\n3\nSample Output\n20 6 2 7 4 15 9\nExplanation\nThe original list is . After deleting the node at position , the list is .",
        "191": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven a pointer to the head of a singly-linked list, print each value from the reversed list. If the given list is empty, do not print anything.\nExample\nrefers to the linked list with values\nPrint the following:\n3\n2\n1\nFunction Description\nComplete the reversePrint function in the editor below.\nreversePrint has the following parameters:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nPrints\nThe values of each node in the reversed list.\nInput Format\nThe first line of input contains , the number of test cases.\nThe input of each test case is as follows:\nThe first line contains an integer , the number of elements in the list.\nEach of the next n lines contains a data element for a list node.\nConstraints\n, where is the element in the list.\nSample Input\n3\n5\n16\n12\n4\n2\n5\n3\n7\n3\n9\n5\n5\n1\n18\n3\n13\nSample Output\n5\n2\n4\n12\n16\n9\n3\n7\n13\n3\n18\n1\n5\nExplanation\nThere are three test cases. There are no blank lines between test case output.\nThe first linked list has elements: . Printing this in reverse order produces:\n5\n2\n4\n12\n16\nThe second linked list has elements: . Printing this in reverse order produces:\n9\n3\n7\nThe third linked list has elements: . Printing this in reverse order produces:\n13\n3\n18\n1\n5",
        "192": "This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\nGiven the pointer to the head node of a linked list, change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.\nExample\nreferences the list\nManipulate the pointers of each node in place and return , now referencing the head of the list .\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the values of the elements in the linked list.\nConstraints\n, where is the element in the list.\nSample Input\n1\n5\n1\n2\n3\n4\n5\nSample Output\n5 4 3 2 1 \nExplanation\nThe initial linked list is: .\nThe reversed linked list is: .",
        "193": "This challenge is part of a tutorial track by MyCodeSchool\nYou\u2019re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. If all data attributes are equal and the lists are the same length, return . Otherwise, return .\nExample\n\nThe two lists have equal data attributes for the first nodes. is longer, though, so the lists are not equal. Return .\nFunction Description\nComplete the compare_lists function in the editor below.\ncompare_lists has the following parameters:\nSinglyLinkedListNode llist1: a reference to the head of a list\nSinglyLinkedListNode llist2: a reference to the head of a list\nReturns\nint: return 1 if the lists are equal, or 0 otherwise\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test cases has the following format:\nThe first line contains an integer , the number of nodes in the first linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nThe next line contains an integer , the number of nodes in the second linked list.\nEach of the next lines contains an integer, each a value for a data attribute.\nConstraints\nOutput Format\nCompare the two linked lists and return 1 if the lists are equal. Otherwise, return 0. Do NOT print anything to stdout\/console.\nThe output is handled by the code in the editor and it is as follows:\nFor each test case, in a new line, print if the two lists are equal, else print .\nSample Input\n2\n2\n1\n2\n1\n1\n2\n1\n2\n2\n1\n2\nSample Output\n0\n1\nExplanation\nThere are test cases, each with a pair of linked lists.\nIn the first case, linked lists are: 1 -> 2 -> NULL and 1 -> NULL\nIn the second case, linked lists are: 1 -> 2 -> NULL and 1 -> 2 -> NULL",
        "194": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the heads of two sorted linked lists, merge them into a single, sorted linked list. Either head pointer may be null meaning that the corresponding list is empty.\nExample\nrefers to\nrefers to\nThe new list is\nFunction Description\nComplete the mergeLists function in the editor below.\nmergeLists has the following parameters:\nSinglyLinkedListNode pointer headA: a reference to the head of a list\nSinglyLinkedListNode pointer headB: a reference to the head of a list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the merged list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the length of the first linked list.\nThe next lines contain an integer each, the elements of the linked list.\nThe next line contains an integer , the length of the second linked list.\nThe next lines contain an integer each, the elements of the second linked list.\nConstraints\n, where is the element of the list.\nSample Input\n1\n3\n1\n2\n3\n2\n3\n4\nSample Output\n1 2 3 3 4 \nExplanation\nThe first linked list is:\nThe second linked list is:\nHence, the merged linked list is:",
        "195": "This challenge is part of a tutorial track by MyCodeSchool\nGiven a pointer to the head of a linked list and a specific position, determine the data value at that position. Count backwards from the tail node. The tail is at postion 0, its parent is at 1 and so on.\nExample\nrefers to\nEach of the data values matches its distance from the tail. The value is at the desired position.\nFunction Description\nComplete the getNode function in the editor below.\ngetNode has the following parameters:\nSinglyLinkedListNode pointer head: refers to the head of the list\nint positionFromTail: the item to retrieve\nReturns\nint: the value at the desired position\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case has the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contains an integer, the data value for an element of the linked list.\nThe last line contains an integer , the position from the tail to retrieve the value of.\nConstraints\n, where is the element of the linked list.\nSample Input\n2\n1\n1\n0\n3\n3\n2\n1\n2\nSample Output\n1\n3\nExplanation\nIn the first case, there is one element in linked list with a value of 1. The last (only) element contains 1.\nIn the second case, the list is . The element with position of 2 from tail contains 3.",
        "196": "This challenge is part of a tutorial track by MyCodeSchool\nYou are given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete nodes and return a sorted list with each distinct value in the original list. The given head pointer may be null indicating that the list is empty.\nExample\nrefers to the first node in the list .\nRemove 1 of the data values and return pointing to the revised list .\nFunction Description\nComplete the removeDuplicates function in the editor below.\nremoveDuplicates has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nSinglyLinkedListNode pointer: a reference to the head of the revised list\nInput Format\nThe first line contains an integer , the number of test cases.\nThe format for each test case is as follows:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the value for each of the elements of the linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n5       n = 5\n1       data values = 1, 2, 2, 3, 4\n2\n2\n3\n4\nSample Output\n1 2 3 4 \nExplanation\nThe initial linked list is: .\nThe final linked list is: .",
        "197": "A linked list is said to contain a cycle if any node is visited more than once while traversing the list. Given a pointer to the head of a linked list, determine if it contains a cycle. If it does, return . Otherwise, return .\nExample\nrefers to the list of nodes\nThe numbers shown are the node numbers, not their data values. There is no cycle in this list so return .\nrefers to the list of nodes\nThere is a cycle where node 3 points back to node 1, so return .\nFunction Description\nComplete the has_cycle function in the editor below.\nIt has the following parameter:\nSinglyLinkedListNode pointer head: a reference to the head of the list\nReturns\nint: if there is a cycle or if there is not\nNote: If the list is empty, will be null.\nInput Format\nThe code stub reads from stdin and passes the appropriate argument to your function. The custom test cases format will not be described for this question due to its complexity. Expand the section for the main function and review the code if you would like to figure out how to create a custom case.\nConstraints\nSample Input\nReferences to each of the following linked lists are passed as arguments to your function:\nSample Output\n0\n1\nExplanation\nThe first list has no cycle, so return .\nThe second list has a cycle, so return .",
        "198": "This challenge is part of a tutorial track by MyCodeSchool\nGiven pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge. The merge point is where both lists point to the same node, i.e. they reference the same memory location. It is guaranteed that the two head nodes will be different, and neither will be NULL. If the lists share a common node, return that node's value.\nNote: After the merge point, both lists will share the same node pointers.\nExample\nIn the diagram below, the two lists converge at Node x:\n[List #1] a--->b--->c\n                     \\\n                      x--->y--->z--->NULL\n                     \/\n     [List #2] p--->q\nFunction Description\nComplete the findMergeNode function in the editor below.\nfindMergeNode has the following parameters:\nSinglyLinkedListNode pointer head1: a reference to the head of the first list\nSinglyLinkedListNode pointer head2: a reference to the head of the second list\nReturns\nint: the value of the node where the lists merge\nInput Format\nDo not read any input from stdin\/console.\nThe first line contains an integer , the number of test cases.\nEach of the test cases is in the following format:\nThe first line contains an integer, , the node number where the merge will occur.\nThe next line contains an integer, that is the number of nodes in the first list.\nEach of the following lines contains a value for a node. The next line contains an integer, that is the number of nodes in the second list.\nEach of the following lines contains a value for a node.\nConstraints\nThe lists will merge.\n.\n.\nSample Input\nThe diagrams below are graphical representations of the lists that input nodes and are connected to.\nTest Case 0\n 1\n  \\\n   2--->3--->NULL\n  \/\n 1\nTest Case 1\n1--->2\n      \\\n       3--->Null\n      \/\n     1\nSample Output\n2\n3\nExplanation\nTest Case 0: As demonstrated in the diagram above, the merge node's data field contains the integer .\nTest Case 1: As demonstrated in the diagram above, the merge node's data field contains the integer .",
        "199": "Given a reference to the head of a doubly-linked list and an integer, , create a new DoublyLinkedListNode object having data value and insert it at the proper location to maintain the sort.\nExample\nrefers to the list\nReturn a reference to the new list: .\nFunction Description\nComplete the sortedInsert function in the editor below.\nsortedInsert has two parameters:\nDoublyLinkedListNode pointer head: a reference to the head of a doubly-linked list\nint data: An integer denoting the value of the field for the DoublyLinkedListNode you must insert into the list.\nReturns\nDoublyLinkedListNode pointer: a reference to the head of the list\nNote: Recall that an empty list (i.e., where ) and a list with one element are sorted lists.\nInput Format\nThe first line contains an integer , the number of test cases.\nEach of the test case is in the following format:\nThe first line contains an integer , the number of elements in the linked list.\nEach of the next lines contains an integer, the data for each node of the linked list.\nThe last line contains an integer, , which needs to be inserted into the sorted doubly-linked list.\nConstraints\nSample Input\nSTDIN   Function\n-----   --------\n1       t = 1\n4       n = 4\n1       node data values = 1, 3, 4, 10\n3\n4\n10\n5       data = 5\nSample Output\n1 3 4 5 10\nExplanation\nThe initial doubly linked list is: .\nThe doubly linked list after insertion is:",
        "200": "This challenge is part of a tutorial track by MyCodeSchool\nGiven the pointer to the head node of a doubly linked list, reverse the order of the nodes in place. That is, change the next and prev pointers of the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list.\nNote: The head node might be NULL to indicate that the list is empty.\nFunction Description\nComplete the reverse function in the editor below.\nreverse has the following parameter(s):\nDoublyLinkedListNode head: a reference to the head of a DoublyLinkedList\nReturns\n- DoublyLinkedListNode: a reference to the head of the reversed list\nInput Format\nThe first line contains an integer , the number of test cases.\nEach test case is of the following format:\nThe first line contains an integer , the number of elements in the linked list.\nThe next lines contain an integer each denoting an element of the linked list.\nConstraints\nOutput Format\nReturn a reference to the head of your reversed list. The provided code will print the reverse array as a one line of space-separated integers for each test case.\nSample Input\n1\n4\n1\n2\n3\n4\nSample Output\n4 3 2 1 \nExplanation\nThe initial doubly linked list is:\nThe reversed doubly linked list is:",
        "201": "Complete the function in the editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the preOrder function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's preorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 4 6 \nExplanation\nThe preorder traversal of the binary tree is printed.",
        "202": "Complete the function in the editor below. It received parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.\nInput Format\nOur test code passes the root node of a binary tree to the function.\nConstraints\nNodes in the tree\nOutput Format\nPrint the tree's postorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4\nSample Output\n4 3 6 5 2 1 \nExplanation\nThe postorder traversal is shown.",
        "203": "In this challenge, you are required to implement inorder traversal of a tree.\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.\nInput Format\nOur hidden tester code passes the root node of a binary tree to your $inOrder* function.\nConstraints\nOutput Format\nPrint the tree's inorder traversal as a single line of space-separated values.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 3 4 5 6 \nExplanation\nThe tree's inorder traversal results in as the required result.",
        "204": "The height of a binary tree is the number of edges between the tree's root and its furthest leaf. For example, the following binary tree is of height :\n\nFunction Description\nComplete the getHeight or height function in the editor. It must return the height of a binary tree as an integer.\ngetHeight or height has the following parameter(s):\nroot: a reference to the root of a binary tree.\nNote -The Height of binary tree with single node is taken as zero.\nInput Format\nThe first line contains an integer , the number of nodes in the tree.\nNext line contains space separated integer where th integer denotes node[i].data.\nNote: Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function. In a binary search tree, all nodes on the left branch of a node are less than the node value. All values on the right branch are greater than the node value.\nConstraints\n\nOutput Format\nYour function should return a single integer denoting the height of the binary tree.\nSample Input\nSample Output\n3\nExplanation\nThe longest root-to-leaf path is shown below:\nThere are nodes in this path that are connected by edges, meaning our binary tree's .",
        "205": "Given a pointer to the root of a binary tree, print the top view of the binary tree.\nThe tree as seen from the top the nodes, is called the top view of the tree.\nFor example :\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nTop View :\nComplete the function and print the resulting values on a single line separated by space.\nInput Format\nYou are given a function,\nvoid topView(node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values on a single line separated by space.\nSample Input\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nSample Output\n1 2 5 6\nExplanation\n   1\n    \\\n     2\n      \\\n       5\n      \/  \\\n     3    6\n      \\\n       4\nFrom the top, only nodes are visible.",
        "206": "Given a pointer to the root of a binary tree, you need to print the level order traversal of this tree. In level-order traversal, nodes are visited level by level from left to right. Complete the function and print the values in a single line separated by a space.\nFor example:\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nFor the above tree, the level order traversal is .\nInput Format\nYou are given a function,\nvoid levelOrder(Node * root) {\n\n}\nConstraints\nNodes in the tree\nOutput Format\nPrint the values in a single line separated by a space.\nSample Input\n     1\n      \\\n       2\n        \\\n         5\n        \/  \\\n       3    6\n        \\\n         4  \nSample Output\n1 2 5 3 6 4\nExplanation\nWe need to print the nodes level by level. We process each level from left to right.\nLevel Order Traversal: .",
        "207": "You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. You just have to complete the function.\nInput Format\nYou are given a function,\nNode * insert (Node * root ,int data) {\n\n}\nConstraints\nNo. of nodes in the tree 500\nOutput Format\nReturn the root of the binary search tree after inserting the value into the tree.\nSample Input\n        4\n       \/ \\\n      2   7\n     \/ \\\n    1   3\nThe value to be inserted is 6.\nSample Output\n         4\n       \/   \\\n      2     7\n     \/ \\   \/\n    1   3 6",
        "208": "Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit. If they are on the left side of the tree, they will be a 0 (zero). If on the right, they'll be a 1 (one). Only the leaves will contain a letter and its frequency count. All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.\nFor instance, consider the string ABRACADABRA. There are a total of characters in the string. This number should match the count in the ultimately determined root of the tree. Our frequencies are and . The two smallest frequencies are for and , both equal to , so we'll create a tree with them. The root node will contain the sum of the counts of its descendants, in this case . The left node will be the first character encountered, , and the right will contain . Next we have items with a character count of : the tree we just created, the character and the character . The tree came first, so it will go on the left of our new root node. will go on the right. Repeat until the tree is complete, then fill in the 's and 's for the edges. The finished graph looks like:\nInput characters are only present in the leaves. Internal nodes have a character value of \u03d5 (NULL). We can determine that our values for characters are:\nA - 0\nB - 111\nC - 1100\nD - 1101\nR - 10\nOur Huffman encoded string is:\nA B    R  A C     A D     A B    R  A\n0 111 10 0 1100 0 1101 0 111 10 0\nor\n01111001100011010111100\nTo avoid ambiguity, Huffman encoding is a prefix free encoding technique. No codeword appears as a prefix of any other codeword.\nTo decode the encoded string, follow the zeros and ones to a leaf and return the character there.\nYou are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.\nFunction Description\nComplete the function decode_huff in the editor below. It must return the decoded string.\ndecode_huff has the following parameters:\nroot: a reference to the root node of the Huffman tree\ns: a Huffman encoded string\nInput Format\nThere is one line of input containing the plain string, . Background code creates the Huffman tree then passes the head node and the encoded string to the function.\nConstraints\nOutput Format\nOutput the decoded string on a single line.\nSample Input\ns=\"1001011\"\nSample Output\nABACA\nExplanation\nS=\"1001011\"\nProcessing the string from left to right.\nS[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[1]='0' : we move to the left child. \nS[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.\nWe move back to the root.\n\nS[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[4]='0' : we move to the left child. \nS[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.\nWe move back to the root.\n\n S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nDecoded String = \"ABACA\"",
        "209": "You are given pointer to the root of the binary search tree and two values and . You need to return the lowest common ancestor (LCA) of and in the binary search tree.\n\nIn the diagram above, the lowest common ancestor of the nodes and is the node . Node is the lowest node which has nodes and as descendants.\nFunction Description\nComplete the function lca in the editor below. It should return a pointer to the lowest common ancestor node of the two values given.\nlca has the following parameters:\n- root: a pointer to the root node of a binary search tree\n- v1: a node.data value\n- v2: a node.data value\nInput Format\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers representing values.\nThe third line contains two space-separated integers, and .\nTo use the test data, you will have to create the binary search tree yourself. Here on the platform, the tree will be created for you.\nConstraints\n\n\n\nThe tree will contain nodes with data equal to and .\nOutput Format\nReturn the a pointer to the node that is the lowest common ancestor of and .\nSample Input\n6\n4 2 3 1 7 6\n1 7\nand .\nSample Output\n[reference to node 4]\nExplanation\nLCA of and is , the root in this case.\nReturn a pointer to the node.",
        "210": "A binary tree is a tree which is characterized by one of the following properties:\nIt can be empty (null).\nIt contains a root node only.\nIt contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees.\nIn-order traversal is performed as\nTraverse the left subtree.\nVisit root.\nTraverse the right subtree.\nFor this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf. When you reach a leaf, back up to its parent, check for a right child and visit it if there is one. If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner. Keep doing this until you have traversed the entire tree. You will only store the values of a node as you visit when one of the following is true:\nit is the first node visited, the first time visited\nit is a leaf, should only be visited once\nall of its subtrees have been explored, should only be visited once while this is true\nit is the root of the tree, the first time visited\nSwapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L.\nFor example, in the following tree, we swap children of node 1.\n                                Depth\n    1               1            [1]\n   \/ \\             \/ \\\n  2   3     ->    3   2          [2]\n   \\   \\           \\   \\\n    4   5           5   4        [3]\nIn-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4.\nSwap operation:\nWe define depth of a node as follows:\nThe root node is at depth 1.\nIf the depth of the parent node is d, then the depth of current node will be d+1.\nGiven a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h \u2208 [k, 2k, 3k,...]. In other words, if h is a multiple of k, swap the left and right subtrees of that level.\nYou are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree.\nFunction Description\nComplete the swapNodes function in the editor below. It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation.\nswapNodes has the following parameter(s):\n- indexes: an array of integers representing index values of each , beginning with , the first element, as the root.\n- queries: an array of integers, each representing a value.\nInput Format\nThe first line contains n, number of nodes in the tree.\nEach of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.\nNote: -1 is used to represent a null node.\nThe next line contains an integer, t, the size of .\nEach of the next t lines contains an integer , each being a value .\nOutput Format\nFor each k, perform the swap operation and store the indices of your in-order traversal to your result array. After all swap operations have been performed, return your result array for printing.\nConstraints\nEither or\nEither or\nThe index of a non-null child will always be greater than that of its parent.\nSample Input 0\n3\n2 3\n-1 -1\n-1 -1\n2\n1\n1\nSample Output 0\n3 1 2\n2 1 3\nExplanation 0\nAs nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.\n    1   [s]       1    [s]       1   \n   \/ \\      ->   \/ \\        ->  \/ \\  \n  2   3 [s]     3   2  [s]     2   3\nNote: [s] indicates that a swap operation is done at this depth.\nSample Input 1\n5\n2 3\n-1 4\n-1 5\n-1 -1\n-1 -1\n1\n2\nSample Output 1\n4 2 1 5 3\nExplanation 1\nSwapping child nodes of node 2 and 3 we get\n    1                  1  \n   \/ \\                \/ \\ \n  2   3   [s]  ->    2   3\n   \\   \\            \/   \/ \n    4   5          4   5  \nSample Input 2\n11\n2 3\n4 -1\n5 -1\n6 -1\n7 8\n-1 9\n-1 -1\n10 11\n-1 -1\n-1 -1\n-1 -1\n2\n2\n4\nSample Output 2\n2 9 6 4 1 3 7 5 11 8 10\n2 6 9 4 1 3 7 5 10 8 11\nExplanation 2\nHere we perform swap operations at the nodes whose depth is either 2 or 4 for and then at nodes whose depth is 4 for .\n         1                     1                          1             \n        \/ \\                   \/ \\                        \/ \\            \n       \/   \\                 \/   \\                      \/   \\           \n      2     3    [s]        2     3                    2     3          \n     \/      \/                \\     \\                    \\     \\         \n    \/      \/                  \\     \\                    \\     \\        \n   4      5          ->        4     5          ->        4     5       \n  \/      \/ \\                  \/     \/ \\                  \/     \/ \\      \n \/      \/   \\                \/     \/   \\                \/     \/   \\     \n6      7     8   [s]        6     7     8   [s]        6     7     8\n \\          \/ \\            \/           \/ \\              \\         \/ \\   \n  \\        \/   \\          \/           \/   \\              \\       \/   \\  \n   9      10   11        9           11   10              9     10   11 ",
        "211": "Kitty has a tree, , consisting of nodes where each node is uniquely labeled from to . Her friend Alex gave her sets, where each set contains distinct nodes. Kitty needs to calculate the following expression on each set:\nwhere:\ndenotes an unordered pair of nodes belonging to the set.\ndenotes the number of edges on the unique (shortest) path between nodes and .\nGiven and sets of distinct nodes, calculate the expression for each set. For each set of nodes, print the value of the expression modulo on a new line.\nExample\n\nThe graph looks like this:\n\nThere are three pairs that can be created from the query set: . The distance from to is , from to is , and from to is .\nNow do the summation:\nInput Format\nThe first line contains two space-separated integers, the respective values of (the number of nodes in tree ) and (the number of nodes in the query set).\nEach of the subsequent lines contains two space-separated integers, and , that describe an undirected edge between nodes and .\nThe subsequent lines define each set over two lines in the following format:\nThe first line contains an integer, , the size of the set.\nThe second line contains space-separated integers, the set's elements.\nConstraints\nThe sum of over all does not exceed .\nAll elements in each set are distinct.\nSubtasks\nfor of the maximum score.\nfor of the maximum score.\nfor of the maximum score.\nOutput Format\nPrint lines of output where each line contains the expression for the query, modulo .\nSample Input 0\n7 3\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n2\n2 4\n1\n5\n3\n2 4 5\nSample Output 0\n16\n0\n106\nExplanation 0\nTree looks like this:\nWe perform the following calculations for sets:\nSet : Given set , the only pair we can form is , where . We then calculate the following answer and print it on a new line:\nSet : Given set , we cannot form any pairs because we don't have at least two elements. Thus, we print on a new line.\nSet : Given set , we can form the pairs , , and . We then calculate the following answer and print it on a new line:",
        "212": "For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements:\nThe value of every node in a node's left subtree is less than the data value of that node.\nThe value of every node in a node's right subtree is greater than the data value of that node.\nGiven the root node of a binary tree, can you determine if it's also a binary search tree?\nComplete the function in your editor below, which has parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.\nInput Format\nYou are not responsible for reading any input from stdin. Hidden code stubs will assemble a binary tree and pass its root node to your function as an argument.\nConstraints\nOutput Format\nYou are not responsible for printing any output to stdout. Your function must return true if the tree is a binary search tree; otherwise, it must return false. Hidden code stubs will print this result as a Yes or No answer on a new line.\nSample Input\nSample Output\nNo",
        "213": "The square-ten tree decomposition of an array is defined as follows:\nThe lowest () level of the square-ten tree consists of single array elements in their natural order.\nThe level (starting from ) of the square-ten tree consists of subsequent array subsegments of length in their natural order. Thus, the level contains subsegments of length , the level contains subsegments of length , the level contains subsegments of length , etc.\nIn other words, every level (for every ) of square-ten tree consists of array subsegments indexed as:\nLevel consists of array subsegments indexed as .\nThe image below depicts the bottom-left corner (i.e., the first array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:\nTask\nGiven the borders of array subsegment , find its decomposition into a minimal number of nodes of a square-ten tree. In other words, you must find a subsegment sequence such as for every , , , where every belongs to any of the square-ten tree levels and is minimal amongst all such variants.\nInput Format\nThe first line contains a single integer denoting .\nThe second line contains a single integer denoting .\nConstraints\nThe numbers in input do not contain leading zeroes.\nOutput Format\nAs soon as array indices are too large, you should find a sequence of square-ten tree level numbers, , meaning that subsegment belongs to the level of the square-ten tree.\nPrint this sequence in the following compressed format:\nOn the first line, print the value of (i.e., the compressed sequence block count).\nFor each of the subsequent lines, print space-separated integers, and (, ), meaning that the number appears consequently times in sequence . Blocks should be listed in the order they appear in the sequence. In other words, should be equal to , should be equal to , etc.\nThus must be true and must be true for every . All numbers should be printed without leading zeroes.\nSample Input 0\n1\n10\nSample Output 0\n1\n1 1\nExplanation 0\nSegment belongs to level of the square-ten tree.",
        "214": "Greg has a tree of nodes containing integer data. He wants to insert a node with some non-zero integer value somewhere into the tree. His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount. This is called a balanced forest. Being frugal, the data value he inserts should be minimal. Determine the minimal amount that a new node can have to allow creation of a balanced forest. If it's not possible to create a balanced forest, return -1.\nFor example, you are given node values and . It is the following tree:\nThe blue node is root, the first number in a node is node number and the second is its value. Cuts can be made between nodes and and nodes and to have three trees with sums , and . Adding a new node of to the third tree completes the solution.\nFunction Description\nComplete the balancedForest function in the editor below. It must return an integer representing the minimum value of that can be added to allow creation of a balanced forest, or if it is not possible.\nbalancedForest has the following parameter(s):\nc: an array of integers, the data values for each node\nedges: an array of 2 element arrays, the node pairs per edge\nInput Format\nThe first line contains a single integer, , the number of queries.\nEach of the following sets of lines is as follows:\nThe first line contains an integer, , the number of nodes in the tree.\nThe second line contains space-separated integers describing the respective values of , where each denotes the value at node .\nEach of the following lines contains two space-separated integers, and , describing edge connecting nodes and .\nConstraints\nEach query forms a valid undirected tree.\nSubtasks\nFor of the maximum score:\nFor of the maximum score:\nOutput Format\nFor each query, return the minimum value of the integer . If no such value exists, return instead.\nSample Input\n2\n5\n1 2 2 1 1\n1 2\n1 3\n3 5\n1 4\n3\n1 3 5\n1 3\n1 2\nSample Output\n2\n-1\nExplanation\nWe perform the following two queries:\nThe tree initially looks like this:\n\nGreg can add a new node with and create a new edge connecting nodes and . Then he cuts the edge connecting nodes and and the edge connecting nodes and . We now have a three-tree balanced forest where each tree has a sum of .\nIn the second query, it's impossible to add a node in such a way that we can split the tree into a three-tree balanced forest so we return .",
        "215": "Jenny loves experimenting with trees. Her favorite tree has nodes connected by edges, and each edge is unit in length. She wants to cut a subtree (i.e., a connected part of the original tree) of radius from this tree by performing the following two steps:\nChoose a node, , from the tree.\nCut a subtree consisting of all nodes which are not further than units from node .\nFor example, the blue nodes in the diagram below depict a subtree centered at that has radius :\nGiven , , and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not isomorphic.\nInput Format\nThe first line contains two space-separated integers denoting the respective values of and .\nEach of the next subsequent lines contains two space-separated integers, and , describing a bidirectional edge in Jenny's tree having length .\nConstraints\nSubtasks\nFor of the max score:\nOutput Format\nPrint the total number of different possible subtrees.\nSample Input 0\n7 1\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\nSample Output 0\n3\nExplanation 0\nIn the diagram below, blue nodes denote the possible subtrees:\nThe last subtrees are considered to be the same (i.e., they all consist of two nodes connected by one edge), so we print as our answer.\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\nSample Output 1\n4\nExplanation 1\nIn the diagram below, blue nodes denote the possible subtrees:\nHere, we have four possible different subtrees.",
        "216": "We consider metric space to be a pair, , where is a set and such that the following conditions hold:\nwhere is the distance between points and .\nLet's define the product of two metric spaces, , to be such that:\n, where , .\nSo, it follows logically that is also a metric space. We then define squared metric space, , to be the product of a metric space multiplied with itself: .\nFor example, , where is a metric space. , where .\nIn this challenge, we need a tree-space. You're given a tree, , where is the set of vertices and is the set of edges. Let the function be the distance between two vertices in tree (i.e., is the number of edges on the path between vertices and ). Note that is a metric space.\nYou are given a tree, , with vertices, as well as points in . Find and print the distance between the two furthest points in this metric space!\nInput Format\nThe first line contains two space-separated positive integers describing the respective values of (the number of vertices in ) and (the number of given points).\nEach line of the subsequent lines contains two space-separated integers, and , describing edge in .\nEach line of the subsequent lines contains two space-separated integers describing the respective values of and for point .\nConstraints\nScoring\nThis challenge uses binary scoring, so you must pass all test cases to earn a positive score.\nOutput Format\nPrint a single non-negative integer denoting the maximum distance between two of the given points in metric space .\nSample Input 0\n2 2\n1 2\n1 2\n2 1\nSample Output 0\n2\nExplanation 0\nThe distance between points and is .\nSample Input 1\n7 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n3 6\n4 5\n5 5\nSample Output 1\n3\nExplanation 1\nThe best points are and , which gives us a distance of .",
        "217": "Consider an array of integers, . Find and print the total number of pairs such that where .\nInput Format\nThe first line contains an integer, , denoting the number of elements in the array.\nThe second line consists of space-separated integers describing the respective values of .\nConstraints\nScoring\nfor of the test cases.\nfor of the test cases.\nfor of the test cases.\nOutput Format\nPrint a long integer denoting the total number pairs satisfying where .\nSample Input\n5  \n1 1 2 4 2\nSample Output\n8\nExplanation\nThere are eight pairs of indices satisfying the given criteria: , , , , , , , and . Thus, we print as our answer.",
        "218": "An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.\nWe define balance factor for each node as :\nbalanceFactor = height(left subtree) - height(right subtree)\nThe balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than \u22121 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.\n(https:\/\/en.wikipedia.org\/wiki\/AVL_tree)\nYou are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced.\nInput Format\nYou are given a function,\nnode *insert(node * root,int new_val)\n{\n\n\n}\n'node' is defined as :\nstruct node\n{\nint val;            \/\/value\nstruct node* left;  \/\/left child\nstruct node* right; \/\/right child\nint ht;             \/\/height of the node\n} node;\nYou only need to complete the function.\nNote: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.\n\nOutput Format\nInsert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced.\nSample Input\n    3\n  \/  \\\n 2    4\n       \\\n        5\nThe value to be inserted is 6.\nSample Output\n    3\n  \/  \\\n 2    5\n     \/ \\\n    4   6\nExplanation\nAfter inserting 6 in the tree. the tree becomes:\n    3 (Balance Factor = -2)\n  \/  \\\n 2    4 (Balance Factor = -2)\n       \\\n        5 (Balance Factor = -1)\n         \\\n          6 (Balance Factor = 0)\nBalance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree.\nAfter performing the rotation, the tree becomes :\n                              3 (Balance Factor = -1)\n                            \/   \\\n      (Balance Factor = 0) 2     5 (Balance Factor = 0)\n                                \/ \\\n           (Balance Factor = 0)4   6 (Balance Factor = 0)",
        "219": "Given two numbers and . indicates the number of elements in the array and indicates number of queries. You need to perform two types of queries on the array .\nYou are given queries. Queries can be of two types, type 1 and type 2.\nType 1 queries are represented as 1 i j : Modify the given array by removing elements from to and adding them to the front.\nType 2 queries are represented as 2 i j : Modify the given array by removing elements from to and adding them to the back.\nYour task is to simply print of the resulting array after the execution of queries followed by the resulting array.\nNote While adding at back or front the order of elements is preserved.\nInput Format\nFirst line consists of two space-separated integers, and .\nSecond line contains integers, which represent the elements of the array.\nqueries follow. Each line contains a query of either type 1 or type 2 in the form\nConstraints\n\n\nOutput Format\nPrint the absolute value i.e. in the first line.\nPrint elements of the resulting array in the second line. Each element should be seperated by a single space.\nSample Input\n8 4\n1 2 3 4 5 6 7 8\n1 2 4\n2 3 5\n1 4 7\n2 1 4\nSample Output\n1\n2 3 6 5 7 8 4 1\nExplanation\nGiven array is .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nAfter execution of query , the array becomes .\nNow is i.e. and the array is",
        "220": "The median of numbers is defined as the middle number after sorting them in order if is odd. Or it is the average of the middle two numbers if is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median.\nExample:\nFor a set of numbers the median is the third number in the sorted set , which is . Similarly, for a set of numbers, , the median is the average of the second and the third element in the sorted set , which is .  \nInput:\nThe first line is an integer, , that indicates the number of operations. Each of the next lines is either a x or r x. a x indicates that is added to the set, and r x indicates that is removed from the set.\nOutput:\nFor each operation: If the operation is add, output the median after adding in a single line. If the operation is remove and the number is not in the list, output Wrong! in a single line. If the operation is remove and the number is in the list, output the median after deleting in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.)\nNote\nIf your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong!\nConstraints:\n\nFor each a x or r x, will always be a signed integer (which will fit in 32 bits).\nSample Input:\n7  \nr 1  \na 1  \na 2  \na 1  \nr 1  \nr 2  \nr 1  \nSample Output:\nWrong!  \n1  \n1.5  \n1  \n1.5  \n1  \nWrong!\nNote: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!. ",
        "221": "People connect with each other in a social network. A connection between Person and Person is represented as . When two persons belonging to different communities connect, the net effect is the merge the communities which and belong to.\nAt the beginning, there are people representing communities. Suppose person and connected and later and connected, then ,, and will belong to the same community.\nThere are two types of queries:\ncommunities containing persons and are merged if they belong to different communities.\nprint the size of the community to which person belongs.\nInput Format\nThe first line of input contains 2 space-separated integers and , the number of people and the number of queries.\nThe next lines will contain the queries.\nConstraints\n\nOutput Format\nThe output of the queries.\nSample Input\nSTDIN Function ----- -------- 3 6 n = 3, q = 6 Q 1 print the size of the community containing person 1 M 1 2 merge the communities containing persons 1 and 2 ... Q 2 M 2 3 Q 3 Q 2\nSample Output\n1\n2\n3\n3\nExplanation\nInitial size of each of the community is .",
        "222": "This question is designed to help you get a better understanding of basic heap operations.\nThere are types of query:\n\" \" - Add an element to the heap.\n\" \" - Delete the element from the heap.\n\"\" - Print the minimum of all the elements in the heap.\nNOTE: It is guaranteed that the element to be deleted will be there in the heap. Also, at any instant, only distinct elements will be in the heap.\nInput Format\nThe first line contains the number of queries, .\nEach of the next lines contains one of the types of query.\nConstraints\n\nOutput Format\nFor each query of type , print the minimum value on a single line.\nSample Input\nSTDIN       Function\n-----       --------\n5           Q = 5\n1 4         insert 4\n1 9         insert 9\n3           print minimum\n2 4         delete 4\n3           print minimum\nSample Output\n4  \n9 \nExplanation\nAfter the first queries, the heap contains {}. Printing the minimum gives as the output. Then, the query deletes from the heap, and the query gives as the output.",
        "223": "You have an empty sequence, and you will be given queries. Each query is one of these three types:\n1 x  -Push the element x into the stack.\n2    -Delete the element present at the top of the stack.\n3    -Print the maximum element in the stack.\nFunction Description\nComplete the getMax function in the editor below.\ngetMax has the following parameters:\n- string operations[n]: operations as strings\nReturns\n- int[]: the answers to each type 3 query\nInput Format\nThe first line of input contains an integer, . The next lines each contain an above mentioned query.\nConstraints\nConstraints\n\n\n\nAll queries are valid.\nSample Input\nSTDIN   Function\n-----   --------\n10      operations[] size n = 10\n1 97    operations = ['1 97', '2', '1 20', ....]\n2\n1 20\n2\n1 26\n1 20\n2\n3\n1 91\n3\nSample Output\n26\n91"
    }
}